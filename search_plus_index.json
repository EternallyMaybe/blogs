{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 网站是通过gitbook制作而成,然后发布在github pages上。主要用于记录平时遇到的问题和学习总结，遇到一些好的文章也会收录在网站中。 搭建过程可以参考这个链接：https://eternallymaybe.github.io/blogs/doc/%E5%85%B6%E4%BB%96/gitbook.html Copyright © Eternally all right reserved，powered by Gitbookmodified at 2019-08-20 04:53:30 "},"doc/JavaScript/":{"url":"doc/JavaScript/","title":"JavaScript","keywords":"","body":"JavaScript 收录与JavaScript相关的一些文章 Copyright © Eternally all right reserved，powered by Gitbookmodified at 2019-08-28 02:21:13 "},"doc/JavaScript/前端新特性/":{"url":"doc/JavaScript/前端新特性/","title":"前端新特性","keywords":"","body":"前端新特性 收录最近新出的前端知识 Copyright © Eternally all right reserved，powered by Gitbookmodified at 2019-08-28 02:23:19 "},"doc/JavaScript/前端新特性/Notification.html":{"url":"doc/JavaScript/前端新特性/Notification.html","title":"Notification","keywords":"","body":"介绍 Notification的通知接口用于向用户配置和显示桌面通知 构造方法 let notification = new Notification(title, options); 参数 title:必要参数，显示的通知标题 options:可选参数，一个被允许用来设置通知的对象 dir:文字方向,auto/ltr(从左到右)/rtl(从右到左) lang:指定通知中所使用的语言 body：通知中额外显示的字符串 tag:赋予通知一个ID，必要时候进行刷新、替换或移除 icon:图标URL,用于显示通知的图标 vibrate:通知显示时候，设备震动硬件需要的振动模式 renotify:true表示新通知替换之前的，false表示不替换 silent:布尔值。通知出现时，是否要有声音 sound:字符串。音频地址，表示通知出现要播放的声音资源。 noscreen:布尔值，是否不在屏幕上显示通知信息。 sticky:布尔值。通知是否具有粘性。 requireInteraction:布尔值。通知是否自动关闭属性 静态属性 Notification.permission denied:拒绝 granted:允许 default:默认(与denied行为表现一致)实例属性 与options内容一致实例事件处理 Notification.onclick:处理 click 事件的处理。每当用户点击通知时被触发。 Notification.onshow:处理 show 事件的处理。当通知显示的时候被触发。 Notification.onerror:处理 error 事件的处理。每当通知遇到错误时被触发。 Notification.onclose:处理 close 事件的处理。当用户关闭通知时被触发。方法 静态方法 Notification.requestPermission()，用于当前页面向用户申请显示通知的权限。 这个方法只能被用户行为调用（比如：onclick事件），并且不能被其他的方式调用。实例方法 Notification.close():关闭通知 EventTarget.addEventListener(): EventTarget.removeEventListener() EventTarget.dispatchEvent()使用 html:click me js:function notify(title, options) { if (!(Notification in window)) { alert('当前浏览器不支持Notification'); return; } if (Notification.permission === 'granted') { var notification = new Notification(title, options); } else if (Notification.permission !== 'denied') { Notification.requestPermission().then((permission) => { if (permission === 'granted') { var notification = new Notification(title, options); } else { alert('用户拒绝授权，不能显示通知'); } }) } else { alert('用户拒绝授权，不能显示通知'); } } 参考链接 掘金-H5 notification浏览器桌面通知 MDN-notification 张鑫旭-简单了解HTML5中的Web Notification桌面通知 Copyright © Eternally all right reserved，powered by Gitbookmodified at 2019-07-16 03:10:19 "},"doc/JavaScript/基本知识/":{"url":"doc/JavaScript/基本知识/","title":"基本知识","keywords":"","body":"基本知识 收录平时常见的知识点总结 Copyright © Eternally all right reserved，powered by Gitbookmodified at 2019-08-28 02:22:08 "},"doc/JavaScript/基本知识/JavaScript的使用.html":{"url":"doc/JavaScript/基本知识/JavaScript的使用.html","title":"JavaScript的使用","keywords":"","body":"script元素 六个属性: async:规定异步执行脚本（仅适用于外部脚本）。 charset:规定在外部脚本文件中使用的字符编码。 defer:规定是否对脚本执行进行延迟，直到页面加载为止。 language:不赞成使用。规定脚本语言。请使用 type 属性代替它。 src:规定外部脚本文件的 URL。 type:表示编写代码使用脚本语言的内容类型,默认： text/javascript 两种使用方式: 直接在页面中嵌入javascript代码 引用外部javascript文件 标签的位置 html文件是自上而下的执行方式，但引入的css和javascript的顺序有所不同，css引入执行加载时，程序仍然往下执行，而执行到script脚本是则中断线程，待该script脚本执行结束之后程序才继续往下执行。所以，大部分网上讨论是将script脚本放在body之后，那样dom的生成就不会因为长时间执行script脚本而延迟阻塞，加快了页面的加载速度。但又不能将所有的script放在body之后，因为有一些页面的效果的实现，是需要预先动态的加载一些js脚本。所以这些脚本应该放在body之前。 延迟脚本（defer属性） 用法： 定义：defer作用是文档加载完毕了再执行脚本,这样回避免找不到对象的问题,加上 defer 等于在页面完全在入后再执行，相当于 window.onload ，但应用上比 window.onload 更灵活！ 请注意两点： 不要在defer型的脚本程序段中调用document.write命令，因为document.write将产生直接输出效果。 而且，不要在defer型脚本程序段中包括任何立即执行脚本要使用的全局变量或者函数。 一个常用的优化性能的方法是：当脚本不需要立即运行时，在script标签中设置“defer”属性。 (立即脚本没有被包含在一个function块中,因此会在加载过程中执行。) 设置“defer”属性后，IE就不必等待该脚本装载和执行完毕。这样页面加载会更快。一般来说，这也表明立即脚本最好放在function块中，并在 document或者body对象的onload 句柄中处理该函数。在有一些脚本需要依赖用户操作而执行时----例如点击按钮，或者移动鼠标到某个区域----使用该属性非常有用。但当有一些脚本需要 在页面加载过程中或加载完成后执行，使用defer属性得到的好处就不太大。 异步脚本（async） 用法： 浏览器对标记有async属性或defer属性的scripts会立即加载并解析，同时也会支持依赖于这个脚本进行初始化的onload事件。async属性和defer属性的不同之处在于何时执行这个脚本。标注有async属性的Script会在下载完成后即可执行，不需要等待window的load事件。这意味着标记有async属性的脚本并不一定会按在页面中嵌入的顺序执行。而标记有defer属性的脚本却一定会按它们在页面上的顺序依次执行。执行会在解析完全完成后开始，但会在document的DOMContentLoaded事件之前。 延迟脚本和异步脚本区别 defer 和 async 在网络读取（下载）这块儿是一样的，都是异步的（相较于 HTML 解析） 它俩的差别在于脚本下载完之后何时执行，显然 defer 是最接近我们对于应用脚本加载和执行的要求的 关于 defer，此图未尽之处在于它是按照加载顺序执行脚本的，这一点要善加利用 async 则是一个乱序执行的主，反正对它来说脚本的加载和执行是紧紧挨着的，所以不管你声明的顺序如何，只要它加载完了就会立刻执行 仔细想想，async 对于应用脚本的用处不大，因为它完全不考虑依赖（哪怕是最低级的顺序执行），不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的，最典型的例子：Google Analytics Copyright © Eternally all right reserved，powered by Gitbookmodified at 2019-07-23 05:04:02 "},"doc/JavaScript/基本知识/js引擎原理.html":{"url":"doc/JavaScript/基本知识/js引擎原理.html","title":"js引擎原理","keywords":"","body":"js引擎工作原理 名词定义 ECStack(执行环境栈):执行环境的栈，后进先出，保证程序能够按照正确的顺序执行。 EC(执行环境):每个函数都有自己的执行环境，当执行一个函数时，该函数的执行环境会被推入到执行环境栈的顶部并获取执行权。 全局变量对象:包含原有的全局对象属性，还包括全局定义的变量和函数，定义函数时，会为函数添加一个内部属性scope，并将scope指向VO。 VO(变量对象):创建执行环境时与之关联的会有一个变量对象，该环境中的所有变量和函数全都保存在这个对象中。 AO(活动对象):进入到一个执行环境时，此执行环境中的变量和函数都可以被访问到，可以理解为被激活 实例分析 var x = 1; function A(y){ var x = 2; function B(z){ console.log(x+y+z); } return B; } var C = A(1); C(1); 全局初始化 创建一个全局对象 JS引擎构建一个执行环境栈，同时创建一个全局执行环境EC，并将这个全局执行环境EC压入执行环境栈中。 JS引擎创建一个与EC相关联的全局变量对象VOECStack = [ //执行环境栈 EC(G) = { //全局执行环境 VO(G):{ //定义全局变量对象 ... //包含全局对象原有的属性 x = 1; //定义变量x A = function(){...}; //定义函数A A[[scope]] = this; //定义A的scope，并赋值为VO本身 } } ]; 执行函数A JS引擎创建函数A的执行环境EC，然后将EC推入执行环境栈顶部获取执行权 JS引擎创建一个当前函数的活动对象AOECStack = [ //执行环境栈 EC(A) = { //A的执行环境 [scope]:VO(G), //VO是全局变量对象 AO(A) : { //创建函数A的活动对象 y:1, x:2, //定义局部变量x B:function(){...}, //定义函数B B[[scope]] = this; //this指代AO本身，而AO位于scopeChain的顶端，因此B[[scope]]指向整个作用域链 arguments:[],//平时我们在函数中访问的arguments就是AO中的arguments this:window //函数中的this指向调用者window对象 }, scopeChain: //链表初始化为A[[scope]],然后再把AO加入该作用域链的顶端,此时A的作用域链：AO(A)->VO(G) }, EC(G) = { //全局执行环境 VO(G):{ //创建全局变量对象 ... //包含全局对象原有的属性 x = 1; //定义变量x A = function(){...}; //定义函数A A[[scope]] = this; //定义A的scope，A[[scope]] == VO(G) } } ]; 执行函数B 创建函数B的执行环境EC，将EC推入到执行环境栈的顶部并获取执行权。当函数B返回时，A的执行环境就会从栈中被删除，只留下全局执行环境。 创建B的作用域链，初始化B的scope所包含的对象，即包含A的作用域链。ECStack = [ //执行环境栈 EC(B) = { //创建B的执行环境,并处于作用域链的顶端 [scope]:AO(A), //指向函数A的作用域链,AO(A)->VO(G) var AO(B) = { //创建函数B的活动对象 z:1, arguments:[], this:window } scopeChain: //链表初始化为B[[scope]],再将AO(B)加入链表表头，此时B的作用域链：AO(B)->AO(A)-VO(G) }, EC(A), //A的执行环境已经从栈顶被删除, EC(G) = { //全局执行环境 VO:{ //定义全局变量对象 ... //包含全局对象原有的属性 x = 1; //定义变量x A = function(){...}; //定义函数A A[[scope]] = this; //定义A的scope，A[[scope]] == VO(G) } } ]; 注意 闭包就是内部函数的作用域链仍然保持着对父函数活动对象的引用 函数的作用域链包括父对象的作用域链以及当前活动对象 原文地址 探究JS引擎原理 JavaScript深入之执行上下文栈 Copyright © Eternally all right reserved，powered by Gitbookmodified at 2019-08-26 06:14:23 "},"doc/JavaScript/基本知识/this.html":{"url":"doc/JavaScript/基本知识/this.html","title":"this","keywords":"","body":"全局作用域中的this console.log(this); // Window全局对象 在浏览器中执行上面的语句后，我们将得到一个Window对象，这是一个全局对象。在全局作用域内，我们可以通过this访问到所有的全局属性。如下代码所示： var a = 1; console.log(this.a); // 1 函数作用域中的this 现在，我们将this关键字放到函数作用域中，测试代码如下： var a = 1; function test(){ var a = 2; console.log(this.a); // 1 } test(); 我们可以看到此时打印出来的结果仍然是1，也就是说这时候this指向的还是全局对象。这里也可以澄清的是，this并没有指向函数作用域（或者说 是并没有指向函数作用域链中的活动对象，有关活动对象的概念可以参考JavaScript速记5 —— 执行环境、变量对象和作用域链），那么this是否会指向函数本身呢，我们接着来看下面一个例子： var a = 1; function test(){ var a = 2; console.log(this.a); // 1 } test.a = 3; test(); 通过上面的例子，我们知道this也并未指向函数本身。上面的例子中，this最终指向的都是全局对象，那么什么情况下this会指向其他对象呢，我们再来看下面的例子： var a = 1; function test(){ var a = 2; console.log(this.a); // 3 } var obj = {a: 3}; test.call(obj); 上面的例子中this指向了对象obj。既然只有当函数被调用时，才能确定this指向的对象，那么下一节我们就针对不同的函数调用方法下，逐一说明this的使用。 不同函数调用方法下的this 直接调用 var a = 1; function test(){ console.log(this.a); //1 } test(); 很明显，函数被直接调用是this指向的就是全局对象。 作为对象的方法调用 var a = 1; function test(){ console.log(this.a); // 2 } var obj = {a: 2, fn: test}; obj.fn(); 当函数作为对象的方法被调用时，this指向当前调用该方法的对象。 作为构造函数调用 var a = 1; function test(){ this.a = 2; } var obj = new test(); console.log(a); // 1 console.log(obj.a); // 2 通过上面的代码结果可以看到，全局对象中的属性a并没有被改变，此时this指向该构造函数创建的对象。 通过call或apply方法调用 call和apply都是Function对象的方法，都可以用来动态改变this的指向，达成函数复用的目的。这里笔者不在详细介绍这两个方法， 有兴趣的读者可以参考相关文章。需要特别说明的是，这两个方法的第一个参数就是this。由于这两个方法的用法类似，这里我们仅以call方法为例。上例 子： var a = 1; function test(){ console.log(this.a); // 1 } test.call(); call方法的第一个参数是this，在没有实参的情况下，上面例子中this默认指向的对象就是全局对象。我们再来看一个例子： var a = 1; function test(){ console.log(this.a); // 1 } var obj = {a: 2, fn: test}; obj.fn.call(); 上面的例子进一步证明了，即便使用对象的方法调用call，this默认指向的依旧是全局对象。为了改变this的指向，我们需要显式的传递第一个参数过去，如下代码： var a = 1; function test(){ console.log(this.a); // 2 } var obj = {a: 2}; test.call(obj); // 实现原理 Function.prototype.call2 = function(context) { context.fn = this; var args = []; for(var i = 1, len = arguments.length; i 与bind的区别，bind是在EcmaScript5中扩展的方法（IE6,7,8不支持），bind() 方法与 apply 和 call 很相似，也是可以改变函数体内 this 的指向，只不过bind是返回的一个函数 嵌套函数作用域中的this 文章的最后我们再来看一下嵌套函数中的this引用。示例代码如下： var a = 1; function test(){ console.log(this.a); // 2 function test2(){ console.log(this.a); // 1 } test2(); } var obj = {a: 2, fn: test}; obj.fn(); 上面的例子说明，嵌套函数被调用是并没有继承被嵌套函数的this引用，在嵌套函数被调用时，this指向全局对象。在有些应用中，我们需要在嵌套函数中读取调用被嵌套函数的对象的属性，此时可以声明一个局部变量保存this引用，代码如下所示： var a = 1; function test(){ console.log(this.a); // 2 var self = this; function test2(){ console.log(self.a); // 2 } test2(); } var obj = {a: 2, fn: test}; obj.fn(); this指向：调用函数时，你可以把this想象为每个函数内的一个特殊（躲起来的）参数。无论什么时候，JavaScript都会把this放到function内部。它是基于一种非常简单的思想：如果函数直接是某个对象的成员，那么this的值就是这个对象。如果函数不是某个对象的成员那么this的值便设为某种全局对象（常见有，浏览器中的window对象）。下面的内部函数可以清晰的看出这种思想。 如果返回值是一个对象，那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是指向函数的实例 function fn() { this.user = '追梦子'; return {}; // function() {}一样的 } var a = new fn(); console.log(a.user); //undefined function fn() { this.user = '追梦子'; return 1; //或undefined、null等ss } var a = new fn(); console.log(a.user); //追梦子 Copyright © Eternally all right reserved，powered by Gitbookmodified at 2019-07-23 04:58:12 "},"doc/JavaScript/基本知识/new原理.html":{"url":"doc/JavaScript/基本知识/new原理.html","title":"new原理","keywords":"","body":"new主要进行了以下三个操作： 创建一个空对象 空对象的proto指向对象的原型对象 将对象的的this指针替换成空对象 换成代码实现就是以下代码 var obj = {}; obj._proto_ = Fun.prototype; Fun.call(obj); Copyright © Eternally all right reserved，powered by Gitbookmodified at 2019-07-22 05:18:39 "},"doc/JavaScript/基本知识/json.html":{"url":"doc/JavaScript/基本知识/json.html","title":"json","keywords":"","body":"什么是JSON JSON 指的是 JavaScript 对象表示法（JavaScript Object Notation） JSON 是轻量级的文本数据交换格式 JSON 独立于语言 JSON 具有自我描述性，更易理解 JSON与XML XML也是一种数据交换格式，为什么没有选择XML呢？因为XML虽然可以作为跨平台的数据交换格式，但是在JS(JavaScript的简写)中处理 XML非常不方便，同时XML标记比数据多，增加了交换产生的流量，而JSON没有附加的任何标记，在JS中可作为对象处理，所以我们更倾向于选择 JSON来交换数据 JSON的两种结构 JSON有两种表示结构，对象和数组： 对象结构以”{”大括号开始，以”}”大括号结束。中间部分由0或多个以”，”分隔的”key(关键字)/value(值)”对构成，关键字和值之间以”：”分隔，其中关键字是字符串，而值可以是字符串，数值，true,false,null,对象或数组。 数组结构以”[”开始，”]”结束。中间由0或多个以”，”分隔的值列表组成。 认识JSON字符串 字符串：这个很好解释，指使用“”双引号或’’单引号包括的字符。例如：var comStr = 'this is string'; json字符串：指的是符合json格式要求的js字符串。例如：var jsonStr = \"{StudentID:' 100', Name:' tmac ' ,Hometown:'usa'}\"; json对象：指符合json格式要求的js对象。例如：var jsonObj = { StudentID: \"100\", Name: \"tmac\", Hometown: \"usa\" }; 在JS中如何使用JSON JSON是JS的一个子集，所以可以在JS中轻松地读，写JSON。读和写JSON都有两种方法，分别是利用”.”操作符和“[key]”的方式。 var obj = { 1: \"value1\", \"2\": \"value2\", count: 3, person: [ //数组结构JSON对象，可以嵌套使用 { id: 1, name: \"张三\" }, { id: 2, name: \"李四\" } ], object: { //对象结构JSON对象 id: 1, msg: \"对象里的对象\" } }; 从JSON中读取数据 function ReadJSON() { alert(obj.1); //会报语法错误，可以用alert(obj[\"1\"]);说明数字最好不要做关键字 alert(obj.2); //同上 alert(obj.person[0].name); //或者alert(obj.person[0][\"name\"]) alert(obj.object.msg); //或者alert(obj.object[\"msg\"]) } 向JSON中写数据 function Add() { //往JSON对象中增加了一条记录 obj.sex= \"男\" //或者obj[\"sex\"]=\"男\" } 修改JSON中的数据 function Update() { obj.count = 10; //或obj[\"count\"]=10 } 删除JSON中的数据 function Delete() { delete obj.count; } 遍历JSON对象 可以使用for…in…循环来遍历JSON对象中的数据，比如我们要遍历输出obj对象的值 function Traversal() { for (var c in obj) { console.log(c + \":\", obj[c]); } } 解析JSON 1.使用JavaScript的eval()函数 早期JSON解析器基本上就是使用JavaScript的eval()函数，但eval()则可以解析任何字符串，所以eval是不安全的。如： var obj; eval(\"obj={'zhangsan':4}\");//合法的 obj=JSON.parse(\"{'zhangsan':4}\");//抛出异常 console.info(obj); 2.使用JSON对象 ES5提供一个全局的JSON对象，用来序列化(JSON.stringify)和反序列化(JSON.parse)对象为JSON格式。 JSON.parse(text [, reviver]) JSON.parse接受文本(JSON格式)并转换成一个ECMAScript值 。该可选的reviver参数是有带有key和value两个参数的函数，其作用于结果——让过滤和转换返回值成为可能。 var result = JSON.parse('{\"a\": 1, \"b\": \"2\"}', function (key, value) { if (typeof value == 'string') { return parseInt(value); } else { return value; } }) 注意：单引号写在{}外，每个属性名都必须用双引号，否则会抛出异常。 JSON.stringify(value [, replacer [, space]]) JSON.stringify允许作者接受一个ECMAScript值然后转换成JSON格式的字符串。 在其最简单的形式中，JSON.stringify接受一个值返回一个字符串 var nums = { \"first\": 7, \"second\": 14, \"third\": 13 } var luckyNums = JSON.stringify(nums, function (key, value) { if (value == 13) { return undefined; } else { return value; } }); 输出结果： >> luckyNums '{\"first\": 7, \"second\": 14}' 如果replacer方法返回undefined, 则键值对就不会包含在最终的JSON中。我们同样可以传递一个space参数以便获得返回结果的可读性帮助。space参数可以是个数字，表明了作缩进的 JSON字符串或字符串每个水平上缩进的空格数。如果参数是个超过10的数值，或是超过10个字符的字符串，将导致取数值10或是截取前10个字符。 var luckyNums = JSON.stringify(nums, function(key, value) { if (value == 13) { return undefined; } else { return value; } }, 2); 输出结果： >> luckyNums '{ \"first\":7, \"second\":14 }' jQuery $.parseJSON(string); Copyright © Eternally all right reserved，powered by Gitbookmodified at 2019-07-23 07:46:54 "},"doc/JavaScript/基本知识/jsonp.html":{"url":"doc/JavaScript/基本知识/jsonp.html","title":"jsonp","keywords":"","body":"什么是jsonp JSON(JavaScript Object Notation)和JSONP(JSON with Padding)虽然只有一个字母的差别，但其实他们根本不是一回事儿：JSON是一种数据交换格式，而JSONP是一种依靠开发人员的聪明才智创造出的 一种非官方跨域数据交互协议。我们拿最近比较火的谍战片来打个比方，JSON是地下党们用来书写和交换情报的“暗号”，而JSONP则是把用暗号书写的情 报传递给自己同志时使用的接头方式。看到没？一个是描述信息的格式，一个是信息传递双方约定的方法。 JSONP是怎么产生的 一个众所周知的问题，Ajax直接请求普通文件存在跨域无权限访问的问题，甭管你是静态页面、动态网页、web服务、WCF，只要是跨域请求，一律不准； 不过我们又发现，Web页面上调用js文件时则不受是否跨域的影响（不仅如此，我们还发现凡是拥有”src”这个属性的标签都拥有跨域的能力，比如\\、\\、\\）； 于是可以判断，当前阶段如果想通过纯web端（ActiveX控件、服务端代理、属于未来的HTML5之Websocket等方式不算）跨域访问数据就只有一种可能，那就是在远程服务器上设法把数据装进js格式的文件里，供客户端调用和进一步处理； 恰巧我们已经知道有一种叫做JSON的纯字符数据格式可以简洁的描述复杂数据，更妙的是JSON还被js原生支持，所以在客户端几乎可以随心所欲的处理这种格式的数据； 这样子解决方案就呼之欲出了，web客户端通过与调用脚本一模一样的方式，来调用跨域服务器上动态生成的js格式文件（一般以JSON为后缀），显而易见，服务器之所以要动态生成JSON文件，目的就在于把客户端需要的数据装入进去。 客户端在对JSON文件调用成功之后，也就获得了自己所需的数据，剩下的就是按照自己需求进行处理和展现了，这种获取远程数据的方式看起来非常像AJAX，但其实并不一样。 为了便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP，该协议的一个要点就是允许用户传递一个callback 参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数 据了。 JSONP的客户端具体实现 1.我们知道，哪怕跨域js文件中的代码（当然指符合web脚本安全策略的），web页面也是可以无条件执行的。 远程服务器remoteserver.com根目录下有个remote.js文件代码如下： alert('我是远程文件'); 本地服务器localserver.com下有个jsonp.html页面代码如下： 毫无疑问，页面将会弹出一个提示窗体，显示跨域调用成功。 2.现在我们在jsonp.html页面定义一个函数，然后在远程remote.js中传入数据进行调用。 jsonp.html页面代码如下： var localHandler = function(data){ alert('我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：' + data.result); }; remote.js文件代码如下： localHandler({\"result\":\"我是远程js带来的数据\"}); 运行之后查看结果，页面成功弹出提示窗口，显示本地函数被跨域的远程js调用成功，并且还接收到了远程js带来的数据。很欣喜，跨域远程获取数据的目的基 本实现了，但是又一个问题出现了，我怎么让远程js知道它应该调用的本地函数叫什么名字呢？毕竟是jsonp的服务者都要面对很多服务对象，而这些服务对象各自的本地函数都不相同啊？我们接着往下看。 3.聪明的开发者很容易想到，只要服务端提供的js脚本是动态生成的就行了呗，这样调用者可以传一个参数过去告诉服务端“我想要一段调用XXX函数的js代码，请你返回给我”，于是服务器就可以按照客户端的需求来生成js脚本并响应了。 // 得到航班信息查询结果后的回调函数 var flightHandler = function(data){ alert('你查询的航班结果是：票价 ' + data.price + ' 元，' + '余票 ' + data.tickets + ' 张。'); }; // 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码） var url =\"http://flightQuery.com/jsonp/flightResult.aspxcode=CA1998&callback=flight Handler\"; // 创建script标签，设置其属性 var script = document.createElement('script'); script.setAttribute('src', url); // 把script标签加入head，此时调用开始 document.getElementsByTagName('head')[0].appendChild(script); 这次的代码变化比较大，不再直接把远程js文件写死，而是编码实现动态查询，而这也正是jsonp客户端实现的核心部分，本例中的重点也就在于如何完成jsonp调用的全过程。 我们看到调用的url中传递了一个code参数，告诉服务器我要查的是CA1998次航班的信息，而callback参数则 告诉服务器，我的本地回调函数叫做flightHandler，所以请把查询结果传入这个函数中进行调用。 OK，服务器很聪明，这个叫做flightResult.aspx的页面生成了一段这样的代码提供给jsonp.html（服务端的实现这里就不演示了，与你选用的语言无关，说到底就是拼接字符串）： flightHandler({ \"code\": \"CA1998\", \"price\": 1780, \"tickets\": 5 }); 我们看到，传递给flightHandler函数的是一个json，它描述了航班的基本信息。运行一下页面，成功弹出提示窗口，jsonp的执行全过程顺利完成！ 4.到这里为止的话，相信你已经能够理解jsonp的客户端实现原理了吧？剩下的就是如何把代码封装一下，以便于与用户界面交互，从而实现多次和重复调用。 jQuery(document).ready(function(){ $.ajax({ type: \"get\", async: false, url: \"http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998\", dataType: \"jsonp\", jsonp: \"callback\",//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback) jsonpCallback:\"flightHandler\",//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写\"?\"，jQuery会自动为你处理数据 success: function(json){ alert('您查询到航班信息：票价： ' + json.price + ' 元，余票： ' + json.tickets + ' 张。'); }, error: function(){ alert('fail'); } }); }); 为什么这次没有写flightHandler这个函数呢？而且竟然也运行成功了，这就是jQuery的功劳了jquery在处理jsonp类型的ajax时，自动帮你生成回调函数并把数据取出来供success属性方法来调用。 JSONP的缺点： JSONP只能实现GET请求 参考网址 http://kb.cnblogs.com/page/139725/ Copyright © Eternally all right reserved，powered by Gitbookmodified at 2019-07-22 05:43:48 "},"doc/JavaScript/基本知识/垃圾回收.html":{"url":"doc/JavaScript/基本知识/垃圾回收.html","title":"垃圾回收","keywords":"","body":"定义 和C#、Java一样JavaScript有自动垃圾回收机制，也就是说执行环境会负责管理代码执行过程中使用的内存，在开发过程中就无需考虑内存分配及 无用内存的回收问题了。JavaScript垃圾回收的机制很简单：找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是时时的，因为其开销比 较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。 变量生命周期 不再使用的变量也就是生命周期结束的变量，当然只可能是局部变量，全局变量的生命周期直至浏览器卸载页面才会结束。局部变量只在函数的执行过程中存在，而 在这个过程中会为局部变量在栈或堆上分配相应的空间，以存储它们的值，然后再函数中使用这些变量，直至函数结束（闭包中由于内部函数的原因，外部函数并不 能算是结束。 两种常见的方式 标记清除（mark and sweep） 这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离 开环境的时候（函数执行结束）将其标记为“离开环境”。至于怎么标记有很多种方式，比如特殊位的反转、维护一个列表等，这些并不重要，重要的是使用什么策 略，原则上讲不能够释放进入环境的变量所占的内存，它们随时可能会被调用的到。 垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了，因为环境中的变量已经无法访问到这些变量了，然后垃圾回收器相会这些带有标记的变量机器所占空间。 大部分浏览器都是使用这种方式进行垃圾回收，区别在于如何标记及垃圾回收间隔而已，只有低版本IE，不出所料，又是IE。。。 引用计数(reference counting) 在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间。 看起来也不错的方式，为什么很少有浏览器采用，还会带来内存泄露问题呢？主要是因为这种方式没办法解决循环引用问题。比如对象A有一个属性指向对象B，而对象B也有有一个属性指向对象A，这样相互引用 function test() { var a={}; var b={}; a.prop=b; b.prop=a; } 这样a和b的引用次数都是2，即使在test()执行完成后，两个对象都已经离开环境，在标记清除的策略下是没有问题的，离开环境的就被清除，但是 在引用计数策略下不行，因为这两个对象的引用次数仍然是2，不会变成0，所以其占用空间不会被清理，如果这个函数被多次调用，这样就会不断地有空间不会被 回收，造成内存泄露。 在IE中虽然JavaScript对象通过标记清除的方式进行垃圾回收，但BOM与DOM对象却是通过引用计数回收垃圾的，也就是说只要涉及BOM及DOM就会出现循环引用问题。看上面的例子，有同学回觉得太弱了，谁会做这样无聊的事情，其实我们是不是就在做 window.onload=function outerFunction(){ var obj = document.getElementById(\"element\"); obj.onclick=function innerFunction(){}; }; 这段代码看起来没什么问题，但是obj引用了document.getElementById(\"element\")，而document.getElementById(\"element\")的onclick方法会引用外部环境中的变量，自然也包括obj，是不是很隐蔽啊。 最简单的解决方式就是自己手工解除循环引用，比如刚才的函数可以这样 window.onload=function outerFunction(){ var obj = document.getElementById(\"element\"); obj.onclick=function innerFunction(){}; obj=null; }; 什么时候触发垃圾回收 垃圾回收器周期性运行，如果分配的内存非常多，那么回收工作也会很艰巨，确定垃圾回收时间间隔就变成了一个值得思考的问题。IE6的垃圾回收是根据 内存分配量运行的，当环境中存在256个变量、4096个对象、64k的字符串任意一种情况的时候就会触发垃圾回收器工作，看起来很科学，不用按一段时间 就调用一次，有时候会没必要，这样按需调用不是很好吗？但是如果环境中就是有这么多变量等一直存在，现在脚本如此复杂，很正常，那么结果就是垃圾回收器一 直在工作，这样浏览器就没法儿玩儿了。 微软在IE7中做了调整，触发条件不再是固定的，而是动态修改的，初始值和IE6相同，如果垃圾回收器回收的内存分配量低于程序占用内存的15%， 说明大部分内存不可被回收，设的垃圾回收触发条件过于敏感，这时候把临界条件翻倍，如果回收的内存高于85%，说明大部分内存早就该清理了，这时候把触发 条件置回。这样就使垃圾回收工作职能了很多。 同C# 、Java一样我们可以手工调用垃圾回收程序，但是由于其消耗大量资源，而且我们手工调用的不会比浏览器判断的准确，所以不推荐手工调用垃圾回收。 Copyright © Eternally all right reserved，powered by Gitbookmodified at 2019-07-23 04:59:37 "},"doc/JavaScript/基本知识/内存泄露.html":{"url":"doc/JavaScript/基本知识/内存泄露.html","title":"内存泄露","keywords":"","body":"什么是内存泄露 内存泄露是指一块被分配的内存既不能使用，又不能回收，直到浏览器进程结束。在C++中，因为是手动管理内存，内存泄露是经常出现的事情。而现在流行的C#和Java等语言采用了自动垃圾回收方法管理内存，正常使用的情况下几乎不会发生内存泄露。浏览器中也是采用自动垃圾回收方法管理内存，但由于浏览器垃圾回收方法有bug，会产生内存泄露。 内存泄露的几种情况 1. 当页面中元素被移除或替换时，若元素绑定的事件仍没被移除，在IE中不会作出恰当处理，此时要先手工移除事件，不然会存在内存泄露。 var btn = document.getElementById(\"myBtn\"); btn.onclick = function(){ document.getElementById(\"myDiv\").innerHTML = \"Processing...\"; } 应改成下面 var btn = document.getElementById(\"myBtn\"); btn.onclick = function(){ btn.onclick = null; document.getElementById(\"myDiv\").innerHTML = \"Processing...\"; } 或者采用事件委托 document.onclick = function(event){ event = event || window.event; if(event.target.id == \"myBtn\"){ document.getElementById(\"myDiv\").innerHTML = \"Processing...\"; } } 2. var a=document.getElementById(\"xx\"); var b=document.getElementById(\"xxx\"); a.r=b; b.r=a; var a=document.getElementById(\"xx\"); a.r=a; 对于纯粹的 ECMAScript 对象而言，只要没有其他对象引用对象 a、b，也就是说它们只是相互之间的引用，那么仍然会被垃圾收集系统识别并处理。但是，在 Internet Explorer 中，如果循环引用中的任何对象是 DOM 节点或者 ActiveX 对象，垃圾收集系统则不会发现它们之间的循环关系与系统中的其他对象是隔离的并释放它们。最终它们将被保留在内存中，直到浏览器关闭。 3. function bindEvent() { var obj=document.createElement(\"XXX\"); obj.onclick=function(){ //Even if it's a empty function } } 闭包可以维持函数内局部变量，使其得不到释放。上例定义事件回调时，由于是函数内定义函数，并且内部函数--事件回调的引用外暴了，形成了闭包解决之道，将事件处理函数定义在外部，解除闭包 function bindEvent() { var obj=document.createElement(\"XXX\"); obj.onclick=onclickHandler; } function onclickHandler(){ //do something } 或者在定义事件处理函数的外部函数中，删除对dom的引用（题外，《JavaScript权威指南》中介绍过，闭包中，作用域中没用的属性可以删除，以减少内存消耗。） function bindEvent() { var obj=document.createElement(\"XXX\"); obj.onclick=function(){ //Even if it's a empty function } obj=null; } 4. a = {p: {x: 1}}; b = a.p; delete a.p; 执行这段代码之后b.x的值依然是1.由于已经删除的属性引用依然存在，因此在JavaScript的某些实现中，可能因为这种不严谨的代码而造成内存泄露。所以在销毁对象的时候，要遍历属性中属性，依次删除。 5. 自动类型装箱转换 看网上资料，说下面的代码在ie系列中会导致内存泄露，先提个神，具体泄露与否先不管 var s = \"lalala\"; alert(s.length); s本身是一个string而非object，它没有length属性，所以当访问length时，JS引擎会自动创建一个临时String对象封装s，而这个对象一定会泄露。这个bug匪夷所思，所幸解决起来相当容易，记得所有值类型做.运算之前先显式转换一下： var s=\"lalala\"; alert(new String(s).length); 6.某些DOM操作 IE系列的特有问题 简单的来说就是在向不在DOM树上的DOM元素appendChild；IE7中，貌似为了改善内存泄露，IE7采用了极端的解决方案：离开页面时回收所有DOM树上的元素，其它一概不管。 Copyright © Eternally all right reserved，powered by Gitbookmodified at 2019-07-22 06:19:05 "},"doc/JavaScript/基本知识/跨域.html":{"url":"doc/JavaScript/基本知识/跨域.html","title":"跨域","keywords":"","body":"什么是跨域 简单地理解就是因为JavaScript同源策略的限制，a.com域名下的js无法操作b.com或是c.a.com域名下的对象。更详细的说明可以看下表： URL 说明 是否允许通信 http://www.a.com/a.js http://www.a.com/b.js 同一域名下 允许 http://www.a.com/lab/a.js http://www.a.com/script/b.js 同一域名下不同文件夹 允许 http://www.a.com:8000/a.js http://www.a.com/b.js 同一域名，不同端口 不允许 http://www.a.com/a.js https://www.a.com/b.js 同一域名，不同协议 不允许 http://www.a.com/a.js http://70.32.92.74/b.js 域名和域名对应ip 不允许 http://www.a.com/a.js http://script.a.com/b.js 主域相同，子域不同 不允许 http://www.a.com/a.js http://a.com/b.js 同一域名，不同二级域名(同上) 不允许(cookie这种情况下也不允许访问) http://www.cnblogs.com/a.js http://www.a.com/b.js 不同域名 不允许 特别注意两点： 如果是协议和端口造成的跨域问题“前台”是无能为力的， 在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。 “URL的首部”指window.location.protocol +window.location.host，也可以理解为“Domains, protocols and ports must match”。 跨域的几种方式 1. 通过jsonp跨域 见Jsonp原理 2. 通过修改document.domain来跨子域 浏览器都有一个同源策略（同源是指域名，协议，端口相同），其限制之一就是第一种方法中我们说的不能通过ajax的方法去请求不同源中的文档。它的第二个限制是浏览器中不同域的框架之间是不能进行js的交互操作的。有一点需要说明，不同的框架之间（父子或同辈），是能够获取到彼此的window对象的，但蛋疼的是你却不能使用获取到的window对象的属性和方法(html5中的postMessage方法是一个例外，还有些浏览器比如ie6也可以使用top、parent等少数几个属性)，总之，你可以当做是只能获取到一个几乎无用的window对象。比如，有一个页面，它的地址是http://www.example.com/a.html ，在这个页面里面有一个iframe，它的src是http://example.com/b.html, 很显然，这个页面与它里面的iframe框架是不同域的，所以我们是无法通过在页面中书写js代码来获取iframe中的东西的： function onLoad() { var iframe = document.getElementById('iframe'), win = iframe.contentWindow, doc = win.document, name = win.name; } 这个时候，document.domain就可以派上用场了，我们只要把http://www.example.com/a.html 和 http://example.com/b.html这 两个页面的document.domain都设成相同的域名就可以了。但要注意的是，document.domain的设置是有限制的，我们只能把 document.domain设置成自身或更高一级的父域，且主域必须相同。例如：a.b.example.com 中某个文档的document.domain 可以设成a.b.example.com、b.example.com 、example.com中的任意一个，但是不可以设成 c.a.b.example.com,因为这是当前域的子域，也不可以设成baidu.com,因为主域已经不相同了。 在页面 http://www.example.com/a.html 中设置document.domain: document.domain = 'example.com'; function test() { alert(document.getElementById('iframe').contentWindow); } 在页面 http://example.com/b.html 中也设置document.domain，而且这也是必须的，虽然这个文档的domain就是example.com,但是还是必须显示的设置document.domain的值： document.domain = 'example.com'; 这样我们就可以通过js访问到iframe中的各种属性和对象了。 不过如果你想在http://www.example.com/a.html 页面中通过ajax直接请求 http://example.com/b.html页面，即使你设置了相同的document.domain也还是不行的，所以修改document.domain的方法只适用于不同子域的框架间的交互。 如果你想通过ajax的方法去与不同子域的页面交互，除了使用jsonp的方法外，还可以用一个隐藏的iframe来做一个代理。原理就是让这个 iframe载入一个与你想要通过ajax获取数据的目标页面处在相同的域的页面，所以这个iframe中的页面是可以正常使用ajax去获取你要的数据 的，然后就是通过我们刚刚讲得修改document.domain的方法，让我们能通过js完全控制这个iframe，这样我们就可以让iframe去发 送ajax请求，然后收到的数据我们也可以获得了。 3.使用window.name来进行跨域 window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个 window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因 新页面的载入而进行重置。 比如：有一个页面a.html,它里面有这样的代码： window.name = '我是页面a设置得值'; setTimeout(function() { window.location = 'b.html'; }); 再看看b.html页面的代码： alert(window.name); // 读取window.name得值 a.html页面载入后3秒，跳转到了b.html页面，结果为： 我们看到在b.html页面上成功获取到了它的上一个页面a.html给window.name设置的值。如果在之后所有载入的页面都没对 window.name进行修改的话，那么所有这些页面获取到的window.name的值都是a.html页面设置的那个值。当然，如果有需要，其中的 任何一个页面都可以对window.name的值进行修改。注意，window.name的值只能是字符串的形式，这个字符串的大小最大能允许2M左右甚 至更大的一个容量，具体取决于不同的浏览器，但一般是够用了。 上面的例子中，我们用到的页面a.html和b.html是处于同一个域的，但是即使a.html与b.html处于不同的域中，上述结论同样是适用的，这也正是利用window.name进行跨域的原理。下面就来看一看具体是怎么样通过window.name来跨域获取数据的。还是举例说明。比如有一个www.example.com/a.html页面,需要通过a.html页面里的js来获取另一个位于不同域上的页面www.cnblogs.com/data.html里的数据。data.html页面里的代码很简单，就是给当前的window.name设置一个a.html页面想要得到的数据值。data.html里的代码： window.name = '我就是a.html想要得数据.' 那么在a.html页面中，我们怎么把data.html页面载入进来呢？显然我们不能直接在a.html页面中通过改变 window.location来载入data.html页面，因为我们想要即使a.html页面不跳转也能得到data.html里的数据。答案就是在 a.html页面中使用一个隐藏的iframe来充当一个中间人角色，由iframe去获取data.html的数据，然后a.html再去得到 iframe获取到的数据。 充当中间人的iframe想要获取到data.html的通过window.name设置的数据，只需要把这个iframe的src设为www.cnblogs.com/data.html就 行了。然后a.html想要得到iframe所获取到的数据，也就是想要得到iframe的window.name的值，还必须把这个iframe的 src设成跟a.html页面同一个域才行，不然根据前面讲的同源策略，a.html是不能访问到iframe里的window.name属性的。这就是 整个跨域过程。 看下a.html页面的代码： function getData() { var iframe = document.getElementById('proxy'); iframe.onLoad = function() { var data = iframe.contentWindow.name; alert(data); // } iframe.src = 'b.html'; } 上面的代码只是最简单的原理演示代码，你可以对使用js封装上面的过程，比如动态的创建iframe,动态的注册各种事件等等，当然为了安全，获取完数据后，还可以销毁作为代理的iframe。网上也有很多类似的现成代码，有兴趣的可以去找一下。 通过window.name来进行跨域，就是这样子的。 使用HTML5 postMessage window.postMessage(message,targetOrigin) 方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、 FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。调用postMessage方法的window对象是指要接收消息的那一个window对象，该方法的第一个参数message为要发送的消息，类 型只能为字符串；第二个参数targetOrigin用来限定接收消息的那个window对象所在的域，如果不想限定域，可以使用通配符 * 。需要接收消息的window对象，可是通过监听自身的message事件来获取传过来的消息，消息内容储存在该事件对象的data属性中。 上面所说的向其他window对象发送消息，其实就是指一个页面有几个框架的那种情况，因为每一个框架都有一个window对象。在讨论第二种方法 的时候，我们说过，不同域的框架间是可以获取到对方的window对象的，而且也可以使用window.postMessage这个方法。下面看一个简单 的示例，有两个页面 // 这是a.html的代码 function onLoad() { var iframe = document.getElementById('iframe'), win = iframe.contentWindow; win.postMessage('我是来自a.html的消息。'); } // 这是b.html的代码 window.onmessage = function(e) { e = e || event; alert(e.data); } 我们运行a页面后得到的结果: 我们看到b页面成功的收到了消息。使用postMessage来跨域传送数据还是比较直观和方便的，但是缺点是IE6、IE7不支持，所以用不用还得根据实际需要来决定。 反向代理 把远程服务通过代理服务器变成本地的服务，需要借助WEB服务器，Nginx和Apache都支持代理转发 跨域资源共享cors(服务端设置HTTP访问控制，设置相应头部) 通过设置server的header来设置浏览器对于服务器跨域的限制 response.setHeader(\"Access-Control-Allow-Origin\", \"*\"); response.setHeader(\"Access-Control-Allow-Methods\", \"POST, GET, OPTIONS, DELETE\"); response.setHeader(\"Access-Control-Max-Age\", \"3600\"); response.addHeader(\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept\"); Copyright © Eternally all right reserved，powered by Gitbookmodified at 2019-07-23 06:10:00 "},"doc/JavaScript/基本知识/前端攻击方式.html":{"url":"doc/JavaScript/基本知识/前端攻击方式.html","title":"前端攻击方式","keywords":"","body":"前端攻击方式 XSS（跨站脚本攻击） 原理：攻击者在网页上发布包含攻击性代码的数据。当浏览者看到此网页时，特定的脚本就会以浏览者用户的身份和权限来执行。通过XSS可以比较容易地修改用户数据、窃取用户信息，以及造成其它类型的攻击，例如CSRF攻击 防护：确保输出到HTML页面的数据以HTML的方式被转义，过滤标签、属性和事件，cookie设置httpOnly,防止cookie窃取 1、通过js实现 //转义 元素的innerHTML内容即为转义后的字符 function htmlEncode ( str ) { var ele = document.createElement('span'); ele.appendChild( document.createTextNode( str ) ); return ele.innerHTML; //解析 function htmlDecode ( str ) { var ele = document.createElement('span'); ele.innerHTML = str; return ele.textContent; } 2.jquery版本 function htmlEncodeJQ ( str ) { return $('').text( str ).html(); } function htmlDecodeJQ ( str ) { return $('').html( str ).text(); CSRF（站点伪造请求） 原理：攻击者通过各种方法伪造一个请求，模仿用户提交表单的行为，从而达到修改用户的数据，或者执行特定任务的目的。为了假冒用户的身份，CSRF攻击常常和XSS攻击配合起来做，但也可以通过其它手段，例如诱使用户点击一个包含攻击的链接。 防护： 采用POST请求,增加攻击的难度.用户点击一个链接就可以发起GET类型的请求。而POST请求相对比较难，攻击者往往需要借助javascript才能实现 对请求进行认证，确保该请求确实是用户本人填写表单并提交的，而不是第三者伪造的.具体可以在会话中增加token,确保看到信息和提交信息的是同一个人 移除refer字段 参考链接：https://blog.csdn.net/stpeace/article/details/53512283 Http Heads攻击 这个页面可能会意外地执行隐藏在URL中的javascript。类似的情况不仅发生在重定向（Location header）上，也有可能发生在其它headers中，如Set-Cookie header。这种攻击如果成功的话，可以做很多事，例如：执行脚本、设置额外的cookie（Set-Cookie: evil=value）等。 避免这种攻击的方法，就是过滤所有的responseheaders，除去header中出现的非法字符，尤其是CRLF。 服务器一般会限制request headers的大小。例如Apache server默认限制request header为8K。如果超过8K，Aapche Server将会返回400 Bad Request响应： 对于大多数情况，8K是足够大的。假设应用程序把用户输入的某内容保存在cookie中,就有可能超过8K.攻击者把超过8k的header链接发给受害者,就会被服务器拒绝访问.解决办法就是检查cookie的大小,限制新cookie的总大写，减少因header过大而产生的拒绝访问攻击 cookie劫持 通过Java Script非常容易访问到当前网站的cookie。你可以打开任何网站，然后在浏览器地址栏中输入：javascript:alert(doucment.cookie),立刻就可以看到当前站点的cookie（如果有的话）。攻击者可以利用这个特性来取得你的关键信息。例如，和XSS攻击相配合，攻击者在你的浏览器上执行特定的JavaScript脚本，取得你的cookie。假设这个网站仅依赖cookie来验证用户身份，那么攻击者就可以假冒你的身份来做一些事情。 现在多数浏览器都支持在cookie上打上HttpOnly的标记,凡有这个标志的cookie就无法通过Java Script来取得,如果能在关键cookie上打上这个标记，就会大大增强cookie的安全性 SQL注入 原因：SQL注入可以分为平台层注入和代码层注入。前者由不安全的数据库配置或数据库平台的漏洞所致；后者主要是由于程序员对输入未进行细致地过滤，从而执行了非法的数据查询。基于此，SQL注入的产生原因通常表现在以下几方面：①不当的类型处理；②不安全的数据库配置；③不合理的查询集处理；④不当的错误处理；⑤转义字符处理不合适；⑥多个提交处理不当。 防护： 永远不要信任用户的输入。对用户的输入进行校验，可以通过正则表达式，或限制长度；对单引号和双\"-\"进行转换等。 永远不要使用动态拼装sql，可以使用参数化的sql或者直接使用存储过程进行数据查询存取。 永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。 不要把机密信息直接存放，加密或者hash掉密码和敏感的信息。 应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装 sql注入的检测方法一般采取辅助软件或网站平台来检测，软件一般采用sql注入检测工具jsky，网站平台就有亿思网站安全平台检测工具。MDCSOFT SCAN等。采用MDCSOFT-IPS可以有效的防御SQL注入，XSS攻击等。 重定向攻击 原理：一种常用的攻击手段是“钓鱼”。钓鱼攻击者，通常会发送给受害者一个合法链接，当链接被点击时，用户被导向一个似是而非的非法网站，从而达到骗取用户信任、窃取用户资料的目的。为防止这种行为,我们必须对所有的重定向操作进行审核,以避免重定向到一个危险的地方. 防护：白名单,将合法的要重定向的url加到白名单中,非白名单上的域名重定向时拒之,第二种解决方案是重定向token,在合法的url上加上token,重定向时进行验证. 上传文件攻击 文件名攻击,上传的文件采用上传之前的文件名,可能造成:客户端和服务端字符码不兼容,导致文件名乱码问题;文件名包含脚本,从而造成攻击. 文件后缀攻击.上传的文件的后缀可能是exe可执行程序,js脚本等文件,这些程序可能被执行于受害者的客户端,甚至可能执行于服务器上.因此我们必须过滤文件名后缀,排除那些不被许可的文件名后缀. 文件内容攻击.IE6有一个很严重的问题 , 它不信任服务器所发送的content type，而是自动根据文件内容来识别文件的类型，并根据所识别的类型来显示或执行文件.如果上传一个gif文件,在文件末尾放一段js攻击脚本,就有可能被执行.这种攻击,它的文件名和content type看起来都是合法的gif图片,然而其内容却包含脚本,这样的攻击无法用文件名过滤来排除，而是必须扫描其文件内容，才能识别。 参考网址 https://blog.csdn.net/miss_leslie/article/details/78839188 Copyright © Eternally all right reserved，powered by Gitbookmodified at 2019-07-16 03:43:23 "},"doc/JavaScript/基本知识/深度复制.html":{"url":"doc/JavaScript/基本知识/深度复制.html","title":"深度复制","keywords":"","body":"克隆概念 浅复制：原始类型为值传递，对象类型仍为引用传递。 深复制：所有元素或属性均完全复制，与原对象完全脱离，也就是说所有对于新对象的修改都不会反映到原对象中。 浅复制 浅复制就是简单的引用复制 var src = { name:\"src\" } //复制一份src对象的应用 var target = src; target.name = \"target\"; console.log(src.name); //输出target target对象只是src对象的引用值的复制，因此target的改变也会影响src。 深复制 Array的slice和concat方法 Array的slice和concat方法都会返回一个新的数组实例，但是这两个方法对于数组中的对象元素却没有执行深复制，而只是复制了引用了，因此这两个方法并不是真正的深复制，通过以下代码进行理解： var array = [1,2,3]; var array_shallow = array; var array_concat = array.concat(); var array_slice = array.slice(0); console.log(array === array_shallow); //true console.log(array === array_slice); //false console.log(array === array_concat); //false 可以看出，concat和slice返回的不同的数组实例，这与直接的引用复制是不同的。 var array = [1, [1,2,3], {name:\"array\"}]; var array_concat = array.concat(); var array_slice = array.slice(0); //改变array_concat中数组元素的值 array_concat[1][0] = 5; console.log(array[1]); //[5,2,3] console.log(array_slice[1]); //[5,2,3] //改变array_slice中对象元素的值 array_slice[2].name = \"array_slice\"; console.log(array[2].name); //array_slice console.log(array_concat[2].name); //array_slice 通过代码的输出可以看出concat和slice并不是真正的深复制，数组中的对象元素(Object,Array等)只是复制了引用 JSON对象的parse和stringify JSON对象是ES5中引入的新的类型（支持的浏览器为IE8+），JSON对象parse方法可以将JSON字符串反序列化成JS对象，stringify方法可以将JS对象序列化成JSON字符串，借助这两个方法，也可以实现对象的深复制。 var source = { name:\"source\", child:{ name:\"child\" } } var target = JSON.parse(JSON.stringify(source)); //改变target的name属性 target.name = \"target\"; console.log(source.name); //source console.log(target.name); //target //改变target的child target.child.name = \"target child\"; console.log(source.child.name); //child console.log(target.child.name); //target child 从代码的输出可以看出，复制后的target与source是完全隔离的，二者不会相互影响。 这个方法使用较为简单，可以满足基本的深复制需求，而且能够处理JSON格式能表示的所有数据类型，但是对于正则表达式类型、函数类型等无法进行深复制(而且会直接丢失相应的值)，同时如果对象中存在循环引用的情况也无法正确处理 jQuery中的extend复制方法 jQuery中的extend方法可以用来扩展对象，这个方法可以传入一个参数:deep(true or false)，表示是否执行深复制(如果是深复制则会执行递归复制) 自己实现一个copy方法 //util作为判断变量具体类型的辅助模块 var util = (function () { var class2type = {}; [\"Null\", \"Undefined\", \"Number\", \"Boolean\", \"String\", \"Object\", \"Function\", \"Array\", \"RegExp\", \"Date\"].forEach(function (item) { class2type[\"[object \" + item + \"]\"] = item.toLowerCase(); }); function isType(obj, type) { return getType(obj) === type; } function getType(obj) { return class2type[Object.prototype.toString.call(obj)] || \"object\"; } return { isType: isType, getType: getType } })(); function copy(obj, deep) { //如果obj不是对象，那么直接返回值就可以了 if (obj === null || typeof obj !== \"object\") { return obj; } //定义需要的局部变量，根据obj的类型来调整target的类型 var i, target = util.isType(obj, \"array\") ? [] : {}, value, valueType; for (i in obj) { value = obj[i]; valueType = util.getType(value); //只有在明确执行深复制，并且当前的value是数组或对象的情况下才执行递归复制 if (deep && (valueType === \"array\" || valueType === \"object\")) { target[i] = copy(value); } else if (deep && valueType !== \"array\" && valueType !== \"object\") { target[i] = eval(value.toString()); } else { target[i] = value; } } return target; } Copyright © Eternally all right reserved，powered by Gitbookmodified at 2019-07-17 06:20:46 "},"doc/JavaScript/基本知识/数组扁平化.html":{"url":"doc/JavaScript/基本知识/数组扁平化.html","title":"数组扁平化","keywords":"","body":"reduce 遍历数组每一项，若值为数组则递归遍历，否则concat。 function flatten(arr) { return arr.reduce((result, item)=> { return result.concat(Array.isArray(item) ? flatten(item) : item); }, []); } reduce是数组的一种方法，它接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。 reduce包含两个参数：回调函数，传给total的初始值 // 求数组的各项值相加的和： arr.reduce((total, item)=> { // total为之前的计算结果，item为数组的各项值 return total + item; }, 0); toString & split 调用数组的toString方法，将数组变为字符串然后再用split分割还原为数组 function flatten(arr) { return arr.toString().split(',').map(function(item) { return Number(item); }) } 因为split分割后形成的数组的每一项值为字符串，所以需要用一个map方法遍历数组将其每一项转换为数值型 join & split 和上面的toString一样，join也可以将数组转换为字符串 function flatten(arr) { return arr.join(',').split(',').map(function(item) { return parseInt(item); }) } 递归 递归的遍历每一项，若为数组则继续遍历，否则concat function flatten(arr) { var res = []; arr.map(item => { if(Array.isArray(item)) { res = res.concat(flatten(item)); } else { res.push(item); } }); return res; } 扩展运算符 es6的扩展运算符能将二维数组变为一维 [].concat(...[1, 2, 3, [4, 5]]); // [1, 2, 3, 4, 5] 根据这个结果我们可以做一个遍历，若arr中含有数组则使用一次扩展运算符，直至没有为止。 function flatten(arr) { while(arr.some(item=>Array.isArray(item))) { arr = [].concat(...arr); } return arr; } es6方法flat、flatMap flat用于将数据拉平，并返回一个新数组 // 默认拉平1层 [1, 2, [3, [4, 5]]].flat(); // 如需拉平更深层次，需要传一个整数 [1, 2, [3, [4, 5]]].flat(2); flatMap将原数组执行map函数，执行完成之后再调用flat()方法 [2, 3, 4].flatMap((x) => [x, x * 2]) // [2, 4, 3, 6, 4, 8] Copyright © Eternally all right reserved，powered by Gitbookmodified at 2019-07-17 06:07:00 "},"doc/JavaScript/基本知识/沙箱模式.html":{"url":"doc/JavaScript/基本知识/沙箱模式.html","title":"沙箱模式","keywords":"","body":"命名空间 JavaScript本身中没有提供命名空间机制，所以为了避免不同函数、对象以及变量名对全局空间的污染，通常的做法是为你的应用程序或者库创建一个唯一的全局对象，然后将所有方法与属性添加到这个对象上。 var MYAPP = {}; // constructors MYAPP.Parent = function () {}; MYAPP.Child = function () {}; // a variable MYAPP.some_var = 1; // an object MYAPP.modules = {}; // nested objects MYAPP.modules.module1 = {}; MYAPP.modules.module1.data = { a: 1, b: 2 }; MYAPP.modules.module2 = {}; 在这段代码中，你创建了一个全局对象MYAPP,并将其他所有对象、函数作为属性附加到MYAPP上. 通常这是一种较好的避免命名冲突的方法，它被应用在很多项目中，但这种方法有一些缺点: 需要给所有需要添加的函数、变量加上前缀。 因为只有一个全局对象，这意味着一部分代码可以肆意地修改全局对象而导致其余代码的被动更新。 沙箱模式 1. 什么是沙箱模式 沙箱模式常见于YUI3 core,它是一种采用同一构造器（Constructor）生成彼此独立且互不干扰（self-contained）的实例对象，而从避免污染全局对象的方法 2. 用全局构造器创建沙箱 用一个全局构造器，而不是一个全局对象，我们给这个构造器起名为Sandbox(),你可以用这个构造器创建对象，你还可以为构造器传递一个回调函数作为参数，这个回调函数就是你存放代码的独立沙箱环境。 new Sandbox(function(box){ 　　 // your code here... }); 3. 沙箱的特性 创建沙箱时可以不使用'new'操作符 Sandbox()构造器接受一些额外的配置参数，这些参数定义了生成对象所需模块的名称，我们希望代码更加模块化。 4. 初始化对象 在不需要‘new'操作符的情况下，创建一个调用了'ajax'和'event'模块的对象 4.1 以数组的形式传递模块名 Sandbox(['ajax', 'event'], function(box){ 　　 // console.log(box); }); 4.2 以独立的参数形式传递模块名 Sandbox('ajax', 'dom', function(box){ 　　 // console.log(box); }); 4.3 把通配符作为参数传递给构造器，这意味着调用所有可用的模块，为了方便起见，如果没有向构造器传递任何模块名作为参数，构造器会把''作为缺省参数传入，以此调用所用可用模块 Sandbox('*', function(box){ 　　 // console.log(box); }); Sandbox(function(box){ 　　 // console.log(box); }); 4.4 可以初始化沙箱对象多次，甚至你可以嵌套它们，而不用担心彼此间会产生任何冲突 Sandbox('dom', 'event', function(box){ 　　 Sandbox('ajax', function(box) { 　　 }); }); Sandbox()构造器 从上面这些示例可以看出，使用沙箱模式，通过把所有代码逻辑包裹在一个回调函数中，你根据所需模块的不同生成不同的实例，而这些实例彼此互不干扰独立的工作着，从而保护了全局命名空间。 # 5.1 添加模块 因为Sandbox()构造器函数也是对象，所以你可以给它添加一个名为'modules'的属性，这个属性将是一个包含一组键值对的对象，其中每对键值对中Key是需要注册的模块名，而Value则是该模块的入口函数，当构造器初始化时当前实例会作为第一个参数传递给入口函数，这样入口函数就能为该实例添加额外的属性与方法。 Sandbox.modules = {}; Sandbox.modules.dom = function(box) { 　　box.getElement = function() {}; 　　box.getStyle = function() {}; 　　box.foo = \"bar\"; }; Sandbox.modules.event = function(box) { 　　 box.attachEvent = function(){}; 　　box.dettachEvent = function(){}; }; Sandbox.modules.ajax = function(box) { 　　box.makeRequest = function() {}; 　　box.getResponse = function() {}; }; 5.2 实现构造器 几个要点 我们检查this是否为Sandbox的实例，若不是，证明Sandbox没有被new操作符调用，我们将以构造器方式重新调用它。 你可以在构造器内部为this添加属性，同样你也可以为构造器的原型添加属性。 模块名称会以数组、独立参数、通配符‘*'等多种形式传递给构造器。 请注意在这个例子中我们不需要从外部文件中加载模块，但在诸如YUI3中，你可以仅仅加载基础模块（通常被称作种子(seed)),而其他的所有模块则会从外部文件中加载。 一旦我们知道了所需的模块，并初始化他们，这意味着调用了每个模块的入口函数。 回调函数作为参数被最后传入构造器，它将使用最新生成的实例并在最后执行。 function Sandbox() { // turning arguments into an array var args = Array.prototype.slice.call(arguments), // the last argument is the callback callback = args.pop(), // modules can be passed as an array or as individual parameters modules = (args[0] && typeof args[0] === \"string\") ? args : args[0], i; // make sure the function is called // as a constructor if (!(this instanceof Sandbox)) { return new Sandbox(modules, callback); } // add properties to 'this' as needed: this.a = 1; this.b = 2; // now add modules to the core 'this' object // no modules or \"*\" both mean \"use all modules\" if (!modules || modules === '*') { modules = []; for (i in Sandbox.modules) { if (Sandbox.modules.hasOwnProperty(i)) { modules.push(i); } } } // init the required modules for (i = 0; i Copyright © Eternally all right reserved，powered by Gitbookmodified at 2019-07-22 06:27:22 "},"doc/JavaScript/基本知识/设计模式.html":{"url":"doc/JavaScript/基本知识/设计模式.html","title":"设计模式","keywords":"","body":"单例模式 描述： 保证一个特定类仅有一个实例。 var single = (function () { var unique; function getInstance() { // 如果该实例存在，则直接返回，否则就对其实例化 if (unique === undefined) { unique = new Construct(); } return unique; } function Construct() { // ... 生成单例的构造函数的代码 } return { getInstance: getInstance } })(); 工厂模式 var XMLHttpFactory = function () {}; //这是一个简单工厂模式 XMLHttpFactory.createXMLHttp = function () { var XMLHttp = null; if (window.XMLHttpRequest) { XMLHttp = new XMLHttpRequest() } else if (window.ActiveXObject) { XMLHttp = new ActiveXObject(\"Microsoft.XMLHTTP\") } return XMLHttp; } //XMLHttpFactory.createXMLHttp()这个方法根据当前环境的具体情况返回一个XHR对象。 var AjaxHander = function () { var XMLHttp = XMLHttpFactory.createXMLHttp(); } 观察者模式（ 发布订阅模式） 参考自定义事件 策略模式（ 将算法的使用与算法的实现分离开来） var strategies = { \"S\": function (salary) { return salary * 4; }, \"A\": function (salary) { return salary * 3; }, \"B\": function (salary) { return salary * 2; } }; var calculateBonus = function (level, salary) { return strategies[level](salary); }; calculateBonus('S', 20000) 外观模式 将大型逻辑片段简化为一个简单的函数调用操作 var N = window.N || {}; N.tools = { stopPropagation: function (e) { if (e.stopPropagation) { e.stopPropagation(); } else { e.cancelBubble = true; } }, preventDefault: function (e) { if (e.preventDefault) { e.preventDefault(); } else { e.returnValue = false; } }, stopEvent: function (e) { N.tools.stopPropagation(e); N.tools.preventDefault(e); } } 装饰者模式 装饰器模式能够动态地为对象添加功能， 是从一个对象外部来给对象添加功能， 相当于改变了对象的外观。 代理模式 为其他对象提供一种代理以控制对这个对象的访问 function myImage = (function () { var imgNode = document.createElement('img'); document.body.appendChild(imgNode); return { setImg: function (src) { imgNode.src = src; } } })() var proxyImg = (function () { var img = new Image(); img.onload = function () { myImage.setImg(this.src); }; return { setSrc: function (src) { myImage.setImg('img/1.gif'); img.src = src; } } })(); 中介者模式 解除对象与对象之间的紧耦合关系 // 库存量 var goods = { \"roseGold|16G\": 10, \"roseGold|32G\": 10, \"luxuryGold|16G\": 10, \"luxuryGold|32G\": 10 }; var colorSelect = document.getElementById(\"selColor\"), memorySelect = document.getElementById(\"selMemory\"), numberInput = document.getElementById(\"selNum\"), colorInfo = document.getElementById(\"conColor\"), memeryInfo = document.getElementById(\"conMemory\"), numberInfo = document.getElementById(\"conNum\"), nextBtn = document.getElementById(\"nextBtn\"); var mediator = (function () { return { changed: function (obj) { var color = colorSelect.value, // 颜色 memory = memorySelect.value, // 内存 number = +numberInput.value, // 数量 stock = goods[color + '|' + memory]; // 对应颜色的库存量 if (obj === colorSelect) { colorInfo.innerHTML = color; } else if (obj === memorySelect) { memeryInfo.innerHTML = memory; } else if (obj === numberInput) { numberInfo.innerHTML = number; } if (!color) { nextBtn.disabled = true; nextBtn.innerHTML = \"请选择手机颜色\"; return; } if (!memory) { nextBtn.disabled = true; nextBtn.innerHTML = \"请选择手机内存\"; return; } if (!number || (((number - 0) | 0) !== (number - 0))) { nextBtn.disabled = true; nextBtn.innerHTML = \"请选择手机数量\"; return; } if (number > stock) { nextBtn.disabled = true; nextBtn.innerHTML = \"库存不足\"; return; } nextBtn.disabled = false; nextBtn.innerHTML = \"加入购物车\"; } }; })(); // 事件函数 colorSelect.onchange = function () { mediator.changed(this); }; memorySelect.onchange = function () { mediator.changed(this); }; numberInput.oninput = function () { mediator.changed(this); } Copyright © Eternally all right reserved，powered by Gitbookmodified at 2019-07-18 09:34:31 "},"doc/JavaScript/基本知识/查找算法.html":{"url":"doc/JavaScript/基本知识/查找算法.html","title":"查找算法","keywords":"","body":"顺序查找 function seqSearch(arr, data) { for (var i = 0; i 二分查找（ 只对有序的） function binSearch(arr, data) { var upperBound = arr.length - 1, lowerBound = 0; while (lowerBound arr[mid]) { lowerBound = mid + 1; } else { return mid; } } return -1; } Copyright © Eternally all right reserved，powered by Gitbookmodified at 2019-07-22 05:26:46 "},"doc/JavaScript/基本知识/算法.html":{"url":"doc/JavaScript/基本知识/算法.html","title":"算法","keywords":"","body":"冒泡排序 function BubbleSort(arr) { var i = j = 0, total = arr.length; for (i; i a[j + 1]) { var temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; flag = true; } } if (!flag) { return arr; } } return arr; } 选择排序 function SelectSort(arr) { var i = 0, total = arr.length; for (i; i a[j]) { minIndex = j; minValue = arr[j]; } } var temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; } return arr; } 插入排序 function insertSort(arr) { var i, prevIndex, current, len = arr.length for (i = 1; i = 0 && arr[prevIndex] > current) { arr[prevIndex + 1] = arr[prevIndex]; prevIndex--; } arr[prevIndex + 1] = current; } return arr; } 归并排序 function MergeSort(arr) { if (arr.length === 1) return arr; var mid = Math.floor(a.length / 2), left = arr.slice(0, mid), right = arr.slice(mid); return merge(MergeSort(left), MergeSort(right)) } function merge(left, right) { var arr = []; while(left.length > 0 && right.length > 0) { if (left[0] > right[0]) { arr.push(right.shift()); } else { arr.push(left.shift()); } } return arr.concat(left, right); } 快排 // 第一个版本 function quickSort(arr, left, right) { var partitionIndex, left = left ? left : 0, right = right ? right : arr.length - 1; if (left = end) return; var pivot = arr[start], i = start + 1, k = end; while (true) { while (arr[i] pivot) { k--; } if (i >= k) { break; } swap(arr, i, k); } swap(arr, start, k); sort(arr, start, Math.max(0, k - 1)); sort(arr, Math.min(end, k + 1), end); } } } 时间复杂度： 最好的情况是：nlogn,parttionIndex每次取中间值 最坏情况是:n^2,parttionIndex每次取n-1或1 空间复杂度：最好是logn，最坏是n 参考地址：https://blog.csdn.net/owen1190/article/details/76215932 Copyright © Eternally all right reserved，powered by Gitbookmodified at 2019-07-18 09:30:39 "},"doc/css/":{"url":"doc/css/","title":"css","keywords":"","body":"css 收录与css相关的一些文章和新特性 Copyright © Eternally all right reserved，powered by Gitbookmodified at 2019-08-28 02:19:18 "},"doc/css/文本省略.html":{"url":"doc/css/文本省略.html","title":"文本省略","keywords":"","body":"单行文本省略 div { overflow: hidden; white-space: nowrap; text-overflow: ellipsis; } 优缺点 属性是浏览器原始支持，各大浏览器兼容性好，使用简单 只支持单行文本截断，不支持多行文本截取 多行文本省略 1.-webkit-line-clamp实现 div { overflow: hidden; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 2; } 优缺点 响应式截断，根据不同宽度作出调整，文本超出范围显示省略号，否则不显示 -webkit-line-clamp是一个不规范的属性，只有webkit内核的浏览器才支持这个属性,兼容性不好 2.定位元素实现 .wrap { position: relative; overflow: hidden; width: 100%; height: 50px; line-height: 25px; word-break: break-all; } .wrap::after { content: '...'; position: absolute; right: 0; bottom: 0; width: 2em; font-weight: bold; text-align: right; background: -webkit-gradient(linear, left top, right top, from(rgba(255, 255, 255, 0))); background: -moz-linear-gradient(to right, rgba(255, 255, 255, 0) 0%, #fff 50%); background: -o-linear-gradient(to right, rgba(255, 255, 255, 0) 0%, #fff 50%); background: -ms-linear-gradient(to right, rgba(255, 255, 255, 0) 0%, #fff 50%); background: linear-gradient(to right, rgba(255, 255, 255, 0) 0%, #fff 50%); } 优缺点 兼容性好,对各大浏览器有较好的支持 无法识别文字的长短，即文本超出范围才显示省略号,否则不显示 3.利用float进行文本截断 实现原理 当main的高度低于prop，end仍会处于main右下方。 如果main文本过多，高度超过了prop，则end不会停留在右下方，而是掉到了prop下。 realend相对于end位置进行偏移，当main的高度低于prop，realend处于边框外 当main文本过多时，realend刚好覆盖在main的边框的右下角 代码 .wrap { overflow: hidden; height: 50px; line-height: 25px; } .wrap .main { float: right; margin-left: -5px; width: 100%; word-break: break-all; } .wrap::before { content: ''; float: left; width: 5px; height: 50px; } .wrap::after { content: \"...\"; float: right; position: relative; left: 100%; top: -25px; margin-left: -3em; padding-right: 5px; height: 25px; width: 3em; text-align: right; background: -webkit-gradient(linear, left top, right top, from(rgba(255, 255, 255, 0))); background: -moz-linear-gradient(to right, rgba(255, 255, 255, 0) 0%, #fff 50%); background: -o-linear-gradient(to right, rgba(255, 255, 255, 0) 0%, #fff 50%); background: -ms-linear-gradient(to right, rgba(255, 255, 255, 0) 0%, #fff 50%); background: linear-gradient(to right, rgba(255, 255, 255, 0) 0%, #fff 50%); } .... 分析 before元素(即图中prop)的作用是占据一定宽度，当main元素(即图中main)内容超出before元素高度时after元素（即图中end）可以一直处于before的下方 main宽度100%会换行显示，margin-left为-5px是为了让main元素和before元素在同一行，after同样如此。 值得注意的是after的padding值，因为after的margin与width作用，使其显示在wrap外，设置padding值(增加after宽度)并且padding小于等于before宽度，可以显示在before元素下，否则因为过宽而显示在main下方 after(即图中end)设置left、top后，即可从end位置移到realend位置 优缺点 兼容性好，响应式截断，文本超出范围才显示，否则不显示 因为是模拟效果，没办法刚好贴合文字 Copyright © Eternally all right reserved，powered by Gitbookmodified at 2019-07-18 09:14:03 "},"doc/webpack/":{"url":"doc/webpack/","title":"webpack","keywords":"","body":"webpack 收录与webpack相关的一些文章 Copyright © Eternally all right reserved，powered by Gitbookmodified at 2019-08-28 02:20:24 "},"doc/webpack/sourceMap.html":{"url":"doc/webpack/sourceMap.html","title":"sourceMap","keywords":"","body":"为什么引入source map JavaScript脚本正变得越来越复杂。大部分源码（尤其是各种函数库和框架）都要经过转换，才能投入生产环境。 常见的源码转换，主要是以下三种情况 压缩，减小体积。比如jQuery 1.9的源码，压缩前是252KB，压缩后是32KB。 多个文件合并，减少HTTP请求数。 其他语言编译成JavaScript。最常见的例子就是CoffeeScript。 这三种情况，都使得实际运行的代码不同于开发代码，除错（debug）变得困难重重。 通常，JavaScript的解释器会告诉你，第几行第几列代码出错。但是，这对于转换后的代码毫无用处。举例来说，jQuery 1.9压缩后只有3行，每行3万个字符，所有内部变量都改了名字。你看着报错信息，感到毫无头绪，根本不知道它所对应的原始位置。 这就是Source map想要解决的问题。 什么是source map 简单说，Source map就是一个信息文件，里面储存着位置信息。也就是说，转换后的代码的每一个位置，所对应的转换前的位置。有了它，出错的时候，除错工具将直接显示原始代码，而不是转换后的代码。这无疑给开发者带来了很大方便。 version：Source Map的版本号。 sources：转换前的文件列表。 names：转换前的所有变量名和属性名。 mappings：记录位置信息的字符串，经过编码。 file：(可选)转换后的文件名。 sourceRoot：(可选)转换前的文件所在的目录。如果与转换前的文件在同一目录，该项为空。 sourcesContent:(可选)转换前的文件内容列表，与sources列表依次对应。 怎样使用Source Map 主流浏览器均支持Source Map功能，不过Chrome与Firefox需要一些简单的配置 开启开发者工具 打开设置 开启Source Map 如何生成Source Map https://docs.fundebug.com/notifier/javascript/sourcemap/generate/ Copyright © Eternally all right reserved，powered by Gitbookmodified at 2019-07-23 07:58:01 "},"doc/vue/":{"url":"doc/vue/","title":"vue","keywords":"","body":"vue 收录与vue相关的一些文章 Copyright © Eternally all right reserved，powered by Gitbookmodified at 2019-08-28 02:20:06 "},"doc/vue/原理解析.html":{"url":"doc/vue/原理解析.html","title":"原理解析","keywords":"","body":"响应式原理 获取到vue中data 遍历data的keys值，为每个关键字添加defineReactive函数 defineReactive调用Object.defineProperty这个静态方法，为data的keys设置get、set方法 get方法主要是用于依赖收集，收集该keys的所有监听 set，方法用于数据改变时通知监听器调用依赖收集 Dep 在最开始进行一次render，那么所有被渲染所依赖的data中的数据就会被getter收集到Dep的subs中去。在对data中的数据进行修改的时候setter只会触发Dep的subs的函数。Watcher 当调用vue的watch方法时会生成一个watcher,此时会调用一个get，将自身添加到Dep的target对象上，之后调用一次get方法，就会addSub到sub中，在修改data中数据的时候会触发dep对象的notify，通知所有Watcher对象去修改对应视图。具体操作 将观察者Watcher实例赋值给全局的Dep.target，然后触发render操作只有被Dep.target标记过的才会进行依赖收集。有Dep.target的对象会将Watcher的实例push到subs中，在对象被修改出发setter操作的时候dep会调用subs中的Watcher实例的update方法进行渲染。 从源码角度看数据绑定 调用initData，其实这段代码主要做了两件事，一是将_data上面的数据代理到vm上，另一件事通过observe将所有数据变成observable 调用observer方法,尝试创建一个Observer实例（ob），如果成功创建Observer实例则返回新的Observer实例，如果已有Observer实例则返回现有的Observer实例。 Observer为数据加上响应式属性进行双向绑定。如果是对象则进行深度遍历，为每一个子对象都绑定上方法，如果是数组则为每一个成员都绑定上方法。 Watcher是一个观察者对象。依赖收集以后Watcher对象会被保存在Deps中，数据变动的时候会由Deps通知Watcher实例，然后由Watcher实例回调cb进行视图的更新。 来看看Dep类。其实Dep就是一个发布者，可以订阅多个观察者，依赖收集之后Deps中会存在一个或多个Watcher对象，在数据变更的时候通知所有的Watcher。 defineReactive的作用是通过Object.defineProperty为数据定义上getter\\setter方法，进行依赖收集后闭包中的Deps会存放Watcher对象。触发setter改变数据的时候会通知Deps订阅者通知所有的Watcher观察者对象进行试图的更新。diff实现 patch将新老VNode节点进行比对，然后将根据两者的比较结果进行最小单位地修改视图，而不是将整个视图根据新的VNode重绘。patch的核心在于diff算法，这套算法可以高效地比较virtual DOM的变更，得出变化以修改视图。 diff算法是通过同层的树节点进行比较而非对树进行逐层搜索遍历的方式，所以时间复杂度只有O(n)，是一种相当高效的算法。从代码中不难发现，当oldVnode与vnode在sameVnode的时候才会进行patchVnode，也就是新旧VNode节点判定为同一节点的时候才会进行patchVnode这个过程，否则就是创建新的DOM，移除旧的DOM。 sameVnode，当两个VNode的tag、key、isComment都相同，并且同时定义或未定义data的时候，且如果标签为input则type必须相同。这时候这两个VNode则算sameVnode，可以直接进行patchVnode操作。 patchVnode的规则是这样的： 如果新旧VNode都是静态的，同时它们的key相同（代表同一节点），并且新的VNode是clone或者是标记了once（标记v-once属性，只渲染一次），那么只需要替换elm以及componentInstance即可。 新老节点均有children子节点，则对子节点进行diff操作，调用updateChildren，这个updateChildren也是diff的核心。 如果老节点没有子节点而新节点存在子节点，先清空老节点DOM的文本内容，然后为当前DOM节点加入子节点。 当新节点没有子节点而老节点有子节点的时候，则移除该DOM节点的所有子节点。 当新老节点都无子节点的时候，只是文本的替换。 nextTick nextTick的实现比较简单，执行的目的是在microtask或者task中推入一个funtion，在当前栈执行完毕（也行还会有一些排在前面的需要执行的任务）以后执行nextTick传入的funtion 看了源码发现timerFunc会检测当前环境而不同实现，其实就是按照Promise，MutationObserver，setTimeout优先级，哪个存在使用哪个，最不济的环境下使用setTimeout。 这里解释一下，一共有Promise、MutationObserver（对节点的监听，插入完成时触发）以及setTimeout三种尝试得到timerFunc的方法。 优先使用Promise，在Promise不存在的情况下使用MutationObserver，这两个方法的回调函数都会在microtask中执行，新版使用MessageChannel,它们会比setTimeout更早执行，所以优先使用。 如果上述两种方法都不支持的环境则会使用setTimeout，在task尾部推入这个函数，等待调用执行。 参考文档：https://github.com/answershuto/learnVue Copyright © Eternally all right reserved，powered by Gitbookmodified at 2019-07-23 07:48:25 "},"doc/vue/vue项目性能优化.html":{"url":"doc/vue/vue项目性能优化.html","title":"vue项目性能优化","keywords":"","body":"图片优化 图片大小优化，部分图片使用WebP（需要考虑webp兼容性） 在线生成，如智图、又拍云 gulp生成，gulp-webp或gulp-imageisux canvas生成 可以参考https://juejin.im/post/5ad0435c5188255c887c0bae 减少图片请求，使用雪碧图 在线生成：sprites Generator、腾讯的gopng、spriteme 代码生成：gulp.spritesmith或者sass的compass 3.一些较小图片使用base64 页面性能优化 图片或组件懒加载 使用vue-lazyload组件或其他一些组件 vue-lazyload地址：https://www.npmjs.com/package/vue-lazyload 图片懒加载：v-lazy或使用v-lazy-container包含一个图片组// 引入一张图片 // 引入一组图片 组件懒加载Vue.use(VueLazyload, { lazyComponent: true }); 图片预加载 快速显示图片 使用场景：在某个查看图片的组件，当不断翻看下一页的图片时，从服务端获取数据再展示图片会出现图片缓慢加载的情况，此时可以在展示新数据时候先预加载图片，图片加载完之后在，将图片填充到对应位置 三方插件懒加载（按需加载） js文件一般是同步加载的，放在页面内会阻塞主要js文件加载。 使用场景：有的项目必须引入jquery等文件时，在组件内部引入这些文件一定程度会阻塞页面渲染，因而通过特定事件（点击或者弹窗）动态加载jquery等JS文件，可以使主页面快速显示出来。 异步加载页面，如何让组件之间不重合 加载多个vue组件时，同时组件是通过服务端数据渲染时，会出现多个组件先重合后分离的状况 四种方案 当页面展示的版块是固定的时候且内容高度不易变动时候，可以预先在组件外设置一个固定高度，显示的时候就像在一个框架里添加内容。当页面内容不固定时候，为了减少异步加载时组件重合的问题，可以在首屏在某组件数据加载完成时候设置其他组件显示，通过v-show显示。 当页面整体固定时，可以为页面增加一个骨架，这样防止页面闪烁的情况 具体实施可以参照https://segmentfault.com/a/1190000012403177 3.预渲染加关键css 预渲染的同时要在页面加载前获取页面所需要的数据，避免加载页面时出现重叠的情况 https://github.com/EternallyMaybe/webpack-demo/blob/master/server-webpack.js 服务端渲染页面,对于一些页面数据固定、更改较少的，可以考虑通过服务端渲染，会在短时间将页面显示出来，有比较好的用户体验。减少引入外部文件大小 框架引入部分ElementUI内容时，通过引入babel-plugin-component配置.babelrc文件，这样即可引入部分组件，从而减少组件的大小。路由懒加载 但使用到vue-router时，webpack会将所有组件打包在一个js文件中，这样就导致这个文件非常大，从而会影响首页的加载，最好的方法就是将其他路由分别打包到不同js文件中，切换路由时再加载对应js文件。resolve => require([URL], resolve), 支持性好 () => system.import(URL) , webpack2官网上已经声明将逐渐废除, 不推荐使用 () => import(URL), webpack2官网推荐使用, 属于es7范畴, 需要配合babel的syntax-dynamic-import插件使用 路由页面缓存 使用vue-router的keep-alive 缓存页面，下次打开页面时候不需要重新加载，显示更快 请求优化 服务器对图片缓存 设置请求缓存，设置cache-control 开启Gzip,压缩响应信息，使传输快 设置DNS缓存 使用HTTP2.0 Copyright © Eternally all right reserved，powered by Gitbookmodified at 2019-07-17 03:09:44 "},"doc/node/":{"url":"doc/node/","title":"node","keywords":"","body":"node 收录与node相关的一些文章 Copyright © Eternally all right reserved，powered by Gitbookmodified at 2019-08-28 02:19:46 "},"doc/node/NPM.html":{"url":"doc/node/NPM.html","title":"NPM","keywords":"","body":"npm模块安装机制 发出npm install命令 npm 向 registry 查询模块压缩包的网址，这个网址后面跟上模块名，就会得到一个 JSON 对象，里面是该模块所有版本的信息。返回的 JSON 对象里面，有一个dist.tarball属性，是该版本压缩包的网址 下载压缩包，存放在~/.npm目录 解压压缩包到当前项目的node_modules目录 注意事项： npm install的时候只会检查node_modules目录而不会检查~/.npm目录，也就是说如果没有安装到node_modules目录中，npm会从远程仓库下载一次新的压缩包。npm 提供了一个--cache-min参数，用于从缓存目录安装模块。--cache-min参数指定一个时间（单位为分钟），只有超过这个时间的模块，才会从 registry 下载$ npm install --cache-min 9999999 离线安装 Registry 代理。 npm install替代。 node_modules作为缓存目录。 npm指令 npm install 安装包 npm ls 查看安装的包 npm ls 查看特定的包 npm update 更新包 npm search 搜索 npm config ls 查看npm配置 npm config set prefix [path] 设置安装全局包路径 （全局包就会安装在这里) npm config set cache [path] 设置包缓存路径，方便下次快速安装包 npm config set registry [path] 设置镜像代理 全局安装地址 window: C:\\Users\\XXX/AppData\\Roaming\\npm\\node_modules Copyright © Eternally all right reserved，powered by Gitbookmodified at 2019-07-23 07:27:59 "},"doc/其他/":{"url":"doc/其他/","title":"其他","keywords":"","body":"其他 收录一些与前端有关的知识 Copyright © Eternally all right reserved，powered by Gitbookmodified at 2019-08-28 02:18:24 "},"doc/其他/webp.html":{"url":"doc/其他/webp.html","title":"webp","keywords":"","body":"什么是Webp图片 WebP是一种新的图片格式，目标是减少文件大小但达到和JPEG格式相同的图片质量，能够减少网络上的请求时间。 优势与劣势 WebP优势 WebP相比于JPG拥有更小的文件尺寸、更高的质量（相比于相同大小不同格式的压缩图片），抽取100张商品图片采用80%压缩，大约能减少60%的文件大小。 WebP劣势 根据Google的测试，目前WebP与JPG相比较，编码速度慢10倍，解码速度慢1.5倍。 编码方面，一般来说，我们可以在图片上传时生成一份WebP图片或者在第一次访问JPG图片时生成WebP图片，对用户体验的影响基本忽略不计。 解码方面，WebP虽然会增加额外的解码时间，但由于减少了文件体积，缩短了加载的时间，页面的渲染速度加快了。同时，随着图片数量的增多，WebP页面加载的速度相对JPG页面增快了。 WebP兼容性 下图为兼容性情况（数据来源于https://caniuse.com/#search=WebP） 就目前而言，WebP支持Chrome和Opera浏览器以及部分手机浏览器 Webp生成方式 在线生成 智图 http://zhitu.isux.us/ 又拍云 https://www.upyun.com/webp CloudConvert https://cloudconvert.com/webp-to-anything iSparta http://isparta.github.io/index.html canvas生成 var canvas = document.createElement('canvas'), ctx = canvas.getContext('2d'), img = document.getElementById('img'); var loadImg = function(url, fn) { var image = new Image(); image.src = url; image.onload = function() { fn(image); } } loadImg('image url', function(image) { canvas.height = image.height; canvas.width = image.width; ctx.drawImage(image, 0, 0); img.setAttribute('src', canvas.toDataURL('image/webp')); }); gulp-WebP或gulp-imageisux 通过使用gulp的两个插件来进行压缩 gulp-WebP var gulp = require('gulp'); var webp = require('gulp-webp'); gulp.task('default', ()=> { gulp.src('./*.{png,jpg,jpeg}') .pipe(webp({quality: 80})) .pipe(gulp.dest('./dist')); }); 有损压缩图片设置webp插件的quality参数，无损压缩设置lossless参数为true即可 gulp-imageisux var imageisux = require('gulp-imageisux'); gulp.task('default', ()=>　{ gulp.src('./*.{png,jpg,jpeg}') .pipe(imageisux('/dirpath/', enableWebp)); }) API 两个参数，dirpath目标目录以及enableWebp是否同时导出对应WEBP格式图片 dirpath: 如果未定义，会自动生成两个目录：'/dest/'目录放压缩后图片，'/webp/'目录放对应的webp格式压缩图片。 enableWebp : 若为true，则会同时输出webp图片；若为false，则只会有压缩后原格式图片。 Copyright © Eternally all right reserved，powered by Gitbookmodified at 2019-07-17 08:07:18 "},"doc/其他/git项目流程.html":{"url":"doc/其他/git项目流程.html","title":"git","keywords":"","body":"1.仓库 源仓库 在项目的开始，项目的发起者构建起一个项目的最原始的仓库，我们把它称为origin，例如我们的PingHackers网站，origin就是这个PingHackers/blog了。源仓库的有两个作用： 汇总参与该项目的各个开发者的代码 存放趋于稳定和可发布的代码 源仓库应该是受保护的，开发者不应该直接对其进行开发工作。只有项目管理者（通常是项目发起人）能对其进行较高权限的操作。 开发者仓库 任何开发者都不会对源仓库进行直接的操作，源仓库建立以后，每个开发者需要做的事情就是把源仓库的“复制”一份，作为自己日常开发的仓库。这个复制，也就是github上面的fork。 每个开发者所fork的仓库是完全独立的，互不干扰，甚至与源仓库都无关。每个开发者仓库相当于一个源仓库实体的影像，开发者在这个影像中进行编码，提交到自己的仓库中，这样就可以轻易地实现团队成员之间的并行开发工作。而开发工作完成以后，开发者可以向源仓库发送pull request，请求管理员把自己的代码合并到源仓库中，这样就实现了分布式开发工作，和最后的集中式的管理。 2.分支 永久性分支 master branch：主分支 develop branch：开发分支 临时性分支 fixbug branch: bug修复分支 feature branch：功能分支 release branch：预发布分支 hotfix branch：bug修复分支 3.工作流 源仓库的构建 开发者fork源仓库 把自己开发者仓库clone到本地 git clone \"git.com\" 构建功能分支进行开发// 切换到`develop`分支 git checkout develop // 分出一个功能性分支 git checkout -b feature-discuss // 假装discuss.js就是我们要开发的功能 touch discuss.js git add . // 提交更改 git commit -m 'finish discuss feature' // 回到develop分支 git checkout develop // 把做好的功能合并到develop中 git merge --no-ff feature-discuss // 删除功能性分支 git branch -d feature-discuss // 把develop提交到自己的远程仓库中 git push origin develop 向管理员提交pull request 管理员测试、合并// 对我的代码进行review // 在他的本地测试新建一个测试分支 git checkout develop // 进入他本地的develop分支 git checkout -b livoras-develop // 从develop分支中分出一个叫livoras-develop的测试分支测试我的代码 git pull https://github.com/livoras/git-demo.git develop // 把我的代码pull到测试分支中，进行测试 // 判断是否同意合并到源仓库的develop中 4.提交规范 Commit message 都包括三个部分：Header，Body 和 Footer。Header 是必需的，Body 和 Footer 可以省略。 Header部分只有一行，包括三个字段：type（必需）、scope（可选）和subject（必需）。 type type用于说明 commit 的类别，只允许使用下面7个标识。 feat：新功能（feature） fix：修补bug docs：文档（documentation） style： 格式（不影响代码运行的变动） refactor：重构（即不是新增功能，也不是修改bug的代码变动） test：增加测试 chore：构建过程或辅助工具的变动 如果type为feat和fix，则该 commit 将肯定出现在 Change log 之中。其他情况（docs、chore、style、refactor、test）由你决定，要不要放入 Change log，建议是不要。 scope scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。 subject subject是 commit 目的的简短描述，不超过50个字符 Body Body 部分是对本次 commit 的详细描述，可以分成多行 其他 git merge --no-ff feature-discuss退出vim 输入i编辑信息 按Esc键 输入：wq,按enter回到原界面 git checkout release, git rebase dev 把你的\"release\"分支里的每个提交(commit)取消掉，并且把它们临时 保存为补丁(patch)(这些补丁放到\".git/rebase\"目录中),然后把\"release\"分支更新 为最新的\"origin\"分支，最后把保存的这些补丁应用到\"release\"分支上。 解决冲突 在解决完冲突后，用\"git-add\"命令去更新这些内容的索引(index), 然后，你无需执行 git-commit,只要执行: git rebase --continue 在任何时候，你可以用--abort参数来终止rebase的行动，并且\"mywork\" 分支会回到rebase开始前的状态。 参考网址 工作流程:https://blog.csdn.net/xiangff_csdn/article/details/52184394 退出vim:https://segmentfault.com/q/1010000005979356/a-1020000005980392 rebase:https://blog.csdn.net/wh_19910525/article/details/7554489 提交规范:http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html gitflow:https://www.jianshu.com/p/9a76e9aa9534 gitflow:https://segmentfault.com/a/1190000006194051 Copyright © Eternally all right reserved，powered by Gitbookmodified at 2019-07-17 07:56:28 "},"doc/其他/搜索引擎原理.html":{"url":"doc/其他/搜索引擎原理.html","title":"搜索引擎原理","keywords":"","body":"组成部分 网页爬取 网页信息的整理存储 索引的建立 搜索的实现 结果排序和最后web实现功能实现 网页爬取与网页信息的提取 爬取网页并保存到本地之后还无法直接使用这些网页文件建立索引，因为这些网页源码中包含大量的HTML标记以及JavaScript脚本代码之类的东西，并且这些数据量远远大于我们所需要的对建立索引来讲有价值的的新闻信息。所以，接下来我们需要分析网页源码，并利用正则表达式对其内容进行提取索引建立 索引的建立使用了Lucene提供的jar包。Document是Lucene建立索引的过程中的一个十分重要的类。Document的意义为文档，在Lucene中，它代表一种逻辑文件。Lucene本身无法对物理文件建立索引，而只能识别并处理Document类型的文件。在某些时候可以将一个Document与一个物理文件进行对应，用一个Document来代替一个物理文件，然而更多的时候，Document和物理的文件没有关系，它作为一种数据源的集合，向Lucene提供原始的要索引的文本内容。Lucene会从Document取出相关的数据源内容，并根据属性配置进行相应的处理 参考资料 一个简单的站内搜索引擎的实现 实战Lucene Copyright © Eternally all right reserved，powered by Gitbookmodified at 2019-07-18 09:18:19 "},"doc/其他/单点登录.html":{"url":"doc/其他/单点登录.html","title":"单点登录","keywords":"","body":"了解单点登录前的一些概念 http是无状态协议 http是无状态协议，浏览器的每一次请求，服务器都会独立处理，不与前后的请求产生联系,如下图： 会话机制 由于http协议无状态，那么怎让浏览器和服务器维护同一状态，这就是会话机制。原理是浏览器第一次请求服务器，服务器创建一个会话，并将会话的id作为响应的一部分发送给浏览器,浏览器存储id,并在后续第二次和第三次请求中带上会话id，服务器取得请求中的会话id就知道是不是同一个用户了，这个过程用下图说明： 常用的会话机制：cookie、url重写 单点登录 为什么引入单点登录 企业发展时通常会产生多个系统，面对如此多的系统，如果每次单独登录就会显得不方便，于是就想到能不能在一个系统登录，其他系统就不用登录了，而这就是单点登录要解决的问题。单点登录英文全称是Single Sign On(以下简称SSO)，它的原理是在多系统应用群中登录一个系统，便可在其他所有系统中得到授权而无需再次登录，包括单点登录与单点注销两部分。 登录 相比于单系统登录，sso需要一个独立的认证中心，只有认证中心能接受用户的用户名密码等安全信息，其他系统不提供登录入口，只接受认证中心的间接授权。间接授权通过令牌实现，sso认证中心验证用户的用户名密码没问题，创建授权令牌，在接下来的跳转过程中，授权令牌作为参数发送给各个子系统，子系统拿到令牌，即得到了授权，可以借此创建局部会话，局部会话登录方式与单系统的登录方式相同。这个过程，也就是单点登录的原理，用下图说明 用户访问系统1的受保护资源，系统1发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数 sso认证中心发现用户未登录，将用户引导至登录页面 用户输入用户名密码提交登录申请 sso认证中心校验用户信息，创建用户与sso认证中心之间的会话，称为全局会话，同时创建授权令牌 sso认证中心带着令牌跳转会最初的请求地址（系统1） 系统1拿到令牌，去sso认证中心校验令牌是否有效 sso认证中心校验令牌，返回有效，注册系统1 系统1使用该令牌创建与用户的会话，称为局部会话，返回受保护资源 用户访问系统2的受保护资源 系统2发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数 sso认证中心发现用户已登录，跳转回系统2的地址，并附上令牌 系统2拿到令牌，去sso认证中心校验令牌是否有效 sso认证中心校验令牌，返回有效，注册系统2 系统2使用该令牌创建与用户的局部会话，返回受保护资源 注销 单点登录自然也要单点注销，在一个子系统中注销，所有子系统的会话都将被销毁，用下面的图来说明： 用户向系统1发起注销请求 系统1根据用户与系统1建立的会话id拿到令牌，向sso认证中心发起注销请求 sso认证中心校验令牌有效，销毁全局会话，同时取出所有用此令牌注册的系统地址 sso认证中心向所有注册系统发起注销请求 各注册系统接收sso认证中心的注销请求，销毁局部会话 sso认证中心引导用户至登录页面 参考地址 https://www.cnblogs.com/ywlaker/p/6113927.html https://yq.aliyun.com/articles/636281 Copyright © Eternally all right reserved，powered by Gitbookmodified at 2019-07-17 02:44:20 "},"doc/其他/gitbook.html":{"url":"doc/其他/gitbook.html","title":"搭建gitbook","keywords":"","body":"什么是gitbook gitbook简单来说就是一款可以在线制作书籍的网站，在这里可以把自己的文档整理成书籍发布出来，便于阅读。具体制作有两种方式，一种是在gitbok官网上进行创作，另外一种使用gitbook工具进行开发。本文主要介绍使用gitbook工具开发这种方式，关于在线制作，大家可以进入官网尝试，不过可能会遇到翻墙问题。 gitbook官网：https://www.gitbook.com/ 使用gitbook工具开发 安装node、git 开发之前先确保已经安装nodejs、git,这是我本机安装的情况，只要能查看到版本信息，就说明安装成功了 ~ node -v v8.12.0 ~ git --version git version 2.19.1.windows.1 安装gitbook命令行工具 Node提供了gitbook的命令行工具gitbook-cli，所以在这里下载一个这样的工具 ~ npm install -g gitbook-cli 查看是否安装成功 ~ gitbook --version CLI version: 2.3.2 GitBook version: 3.2.3 出现版本信息，证明gitbook安装成功 gitbook初始化 创建工作目录，并创建README.md、SUMMARY.md,然后进行初始化 ~ mkdir gitbook ~ cd gitbook ~ touch README.md ~ touch SUMMARY.md 在SUMMARY.md填写自己的目录机构 * [Introduction](README.md) * [第一章](doc/chapter1/README.md) * [第一节](doc/chapter1/page1.md) * [第二节](doc/chapter1/page2.md) * [第二章](doc/chapter2/README.md) * [第一节](doc/chapter2/page1.md) * [第二节](doc/chapter2/page2.md) 开始初始化 gitbook init 目录结构如下 gitbook会自动创建对应的目录和文件。当然你也可以选择先不创建README.md、SUMMARY.md这两个文件，直接使用gitbook init进行初始化，它会自动为你创建这两个文件。 本地启动服务编写书籍 输入gitbook serve命令,启动服务 ~ gitbook serve Live reload server started on port: 35729 Press CTRL+C to quit ... info: 7 plugins are installed info: loading plugin \"livereload\"... OK info: loading plugin \"highlight\"... OK info: loading plugin \"search\"... OK info: loading plugin \"lunr\"... OK info: loading plugin \"sharing\"... OK info: loading plugin \"fontsettings\"... OK info: loading plugin \"theme-default\"... OK info: found 7 pages info: found 6 asset files info: >> generation finished with success in 0.9s ! Starting server ... Serving book on http://localhost:4000 出现以上提示就表示服务已经启动成功，然后在浏览器输入http://localhost:4000 就可以看到效果了 项目部署到github pages 首先了解一下github pages,它是为你的项目提供一个免费的访问站点，并且直接指向你的github仓库，你的仓库更新，站点也自动更新。 紧接着我们把项目分成master、gh-pages两个分支，源码放在master分支上，要部署的网站放在gh-pages分支。 具体操作: 1.在github上创建gitbook仓库 2.在本地项目中创建.gitignore文件,内容如下: _book 3.上传本地项目到github 上传master分支的内容 ~ git init ~ git add . ~ git commit -m 'gitbook init' ~ git remote add origin https://github.com/{username}/gitbook.git ~ git push origin master 上传gh-pages的内容，为了方便可以在根目录创建一个deploy.sh脚本 #!/usr/bin/env sh echo '开始执行命令' # 是否安装node echo '检查是否安装node' if command -v node >/dev/null 2>&1; then echo \"Node exists\" else echo \"Node does not exist\" && exit 0 fi # 是否安装git echo '检查是否安装git' if command -v git >/dev/null 2>&1; then echo \"Git exists\" else echo \"Git does not exist\" && exit 0 fi # 生成静态文件 echo '执行命令：gitbook build .' gitbook build . # 进入生成的文件夹 echo '执行命令：cd ./_book' cd ./_book # 重写图片路径 echo '执行命令：node ./build/renameImgUrl' node ./build/renameImgUrl.js sleep 1 # 初始化一个仓库，仅仅是做了一个初始化的操作，项目里的文件还没有被跟踪 echo \"执行命令：git init\\n\" git init # 保存所有的修改 echo \"执行命令：git add .\" git add . # 把修改的文件提交 echo \"执行命令：commit -m 'deploy'\" git commit -m 'deploy' # 如果发布到 https://.github.io/ echo \"执行命令：git push -f git@github.com:EternallyMaybe/blogs.git master:gh-pages\" git push -f git@github.com:EternallyMaybe/blogs.git master:gh-pages # 返回到上一次的工作目录 echo \"回到刚才工作目录\" cd - 文件保存后，执行bash deploy.sh命令,然后要发布的内容就会被推送到gh-pages分支上，这里需要注意一点，window系统不支持.sh文件，但是git bash却支持这种文件，所以可以在git bash中运行这条命令。 4.发布项目 在github网站上的仓库里面点击Settings -> GitHub Pages选项中 -> Source里面选择gh-pages branch 然后点击Save按钮，然后在GitHub Pages下面就会看见一个网站。 插件 gitbook有插件官网,默认带有5个插件，highlight、search、sharing、font-settings、livereload，如果要去除自带的插件， 可以在插件名称前面加 -，比如： \"plugins\": [ \"-search\" ] 新增插件 { \"plugins\": [\"github\"], \"pluginConfig\": { \"github\": { \"url\": \"https://github.com/your/repo\" } } } 最后在控制台输入gitbook install 项目地址 最后附上本项目的github地址：https://github.com/EternallyMaybe/blogs/ 参考文章 gitbook使用教程:https://segmentfault.com/a/1190000017960359 Github Pages:https://sspai.com/post/54608 gitbook 插件:https://www.cnblogs.com/mingyue5826/p/10307051.html Copyright © Eternally all right reserved，powered by Gitbookmodified at 2019-08-20 05:02:22 "},"doc/其他/文章推荐.html":{"url":"doc/其他/文章推荐.html","title":"文章推荐","keywords":"","body":"文章推荐 站点导航 程序员导航 - 国内最专业的程序员导航！ 掘金 Git - Book HTML/CSS/JS 在线工具 | 菜鸟工具 有道云笔记 YApi-高效、易用、功能强大的可视化接口管理平台 JavaScript Weekly Issue 425: February 22, 2019 Hello TypeScript · TypeScript 入门教程 ProcessOn - 我的文件 vscode 插件推荐 - 献给所有前端工程师（2018.4.29更新） - 大前端时代 - SegmentFault 思否 The State of JavaScript 2018: Demographics React - TypeScript 中文手册 谷歌浏览器开发工具综述 - Chrome 开发工具指南 - 极客学院Wiki 阮一峰的网络日志 VuePress 中文文档 javascript 从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理 纯 CSS 实现多行文字截断 前端异常监控解决方案研究 – 腾讯CDC 使用原理视角看 Git - CODING - SegmentFault 思否 简易的前端路由实现 - js源码分析 - SegmentFault 思否 Director | BootCDN - Bootstrap 中文网开源项目免费 CDN 加速服务 前后端分离实践（一） - 张亚涛 - SegmentFault 思否 React Router DOM 中文文档（一） - 简书 前端埋点 理解HTTP session原理及应用 - 明明是悟空 - 博客园 一个简单的站内搜索引擎的实现 - 知耻后勇，韦编三绝 - CSDN博客 浅析前端开发中的 MVC/MVP/MVVM 模式 - _marven - 博客园 JavaScript 如何工作：对引擎、运行时、调用堆栈的概述 了解资源计时| 面向Web开发人员的工具| Google Developers 基于指令和混合的前端通用埋点方案 - 天空之家 - 博客园 图解CSS：CSS 的值和单位_CSS, 图解CSS, 长度单位 教程_w3cplus React 还是 Vue: 你应该选择哪一个Web前端框架？ - chenxj - 博客园 Performance — 前端性能监控利器 - 冰凌哒雪花 - 博客园 单点登录（SSO）看这一篇就够了-云栖社区-阿里云 剖析Promise内部结构，一步一步实现一个完整的、能通过所有Test case的Promise类 · Issue #3 · xieranmaya/blog CSS Triggers javascript - Why use Redux over Facebook Flux? - Stack Overflow 三种语言能力- F.I.S 移动开发 手机端远程调试-Browsersync - 简书 weinre的使用 - migo_ - 博客园 移动端真机调试指南 | Aotu.io「凹凸实验室」 Fiddler 抓包工具总结 - ﹏猴子请来的救兵 - 博客园 移动端适配大法 - 腾讯Web前端 IMWeb 团队社区 | blog | 团队博客 移动前端开发之viewport的深入理解 - 无双 - 博客园 从网易与淘宝的font-size思考前端设计稿与工作流 - 流云诸葛 - 博客园 Markdown 教程-MarkDown Editor.md - 开源在线 Markdown 编辑器 动画 Awesome Demos from 2018 | Codrops Egret白鹭H5开发-围住神经猫 - 掘金 cubic-bezier(.39,1.43,.86,.17) ✿ cubic-bezier.com jQuery移动端抽奖大转盘页面代码 CSS Tricks 矩阵二进制计算器（乘法，加法，减法） CSSFX - Beautifully simple click-to-copy CSS effects In Pieces - 30 Endangered Species, 30 Pieces. node Node.js 核心(原生)模块整理 - IT笔录 crypto | Node.js API 文档 Node.js加密算法库Crypto | 粉丝日志 NPM包开发 Shields.io: Quality metadata badges for open source projects 如何自己写一个公用的NPM包 - 腾讯Web前端 IMWeb 团队社区 | blog | 团队博客 EditorConfig The MIT License | Open Source Initiative 【译】EditorConfig介绍 | AlloyTeam 博客设计 个人博客数据库设计 | 张甲博客 Node+Koa2+Mysql 搭建简易博客 - wclimb的博客 - CSDN博客 Node.js实现GitHub第三方登录 - 湖工电气的博客 - CSDN博客 12.2 框架设计 · GitBook 搜索指数 百度指数 Google 趋势 linux vi命令示例大全 Linux vi/vim | 菜鸟教程 Shell 教程 | 菜鸟教程 鸟哥的 Linux 私房菜 -- 学习 bash shell 设置Linux环境变量的方法和区别_Ubuntu - 简书 Windows/Linux 下命令可用性检测 规范 Code Guide by @AlloyTeam can - CODELF Can I use... Support tables for HTML5, CSS3, etc 前端开发]--分享个人习惯的命名方式 - 掘金 面试 InterviewMap 学习路线 2019新版前端与移动开发学习路线图 Copyright © Eternally all right reserved，powered by Gitbookmodified at 2019-08-28 02:42:58 "}}